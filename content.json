{"posts":[{"title":"Developing with Spring Boot","text":"Chapter 2. Developing with Spring Boot本节将更详细地介绍如何使用 Spring Boot。涵盖的主题包括构建系统、自动配置以及如何运行应用程序。 如果您刚开始使用Spring Boot，建议您先阅读 “Getting Start” 再深入了解本节内容。 2.1 构建系统我们建议您选择 Maven 或 Gradle 构建系统。 2.1.1 依赖管理每个 Spring Boot 版本都提供了它支持的精选依赖项列表。在实践中，你不需要在你的构建配置中提供这些依赖项的版本，因为 Spring Boot 会为你管理这些依赖项的版本。当你升级 Spring Boot 时，这些依赖项也会一致升级。 如果需要，你仍然可以指定版本并覆盖 Spring Boot 的预设。 列表中包含了所有可以与 Spring Boot 一起使用的 Spring 模块以及精选的第三方库。该清单可作为标准依赖关系清单（spring-boot-dependencies）在 Maven 和 Gradle 中使用。 每个 Spring Boot 版本都与一个 Spring Framework 基础版本相关联。我们强烈建议您不指定其版本。 2.1.2 Maven参考文档：Spring Boot Maven Plugin Documentation 2.1.3 Gradle参考文档：Spring Boot Gradle Plugin Reference Guide 2.1.4 StartersStarters 是一组便捷的依赖描述符，您可以将其包含在您的应用程序中。这样，您就可以一站式获得所需的所有 Spring 和相关技术，而不必在代码中搜索并复制粘贴大量的依赖描述符。例如，如果您想要使用 Spring 和 JPA 进行数据库访问，可以在您的项目中包含 spring-boot-starter-data-jpa 依赖项。Starters 包含了许多依赖项，可以快速地启动项目，并具有一组一致的、受支持的托管传递依赖项。 Starter 的命名规则所有官方的 Starter 都遵循相似的命名规则；即 spring-boot-starter-*，其中 * 是一种特定的应用程序类型。这种命名结构旨在帮助你找到 Starter。许多 IDE 中的 Maven 集成都可以通过名称搜索依赖项。例如，如果安装了适当的 Eclipse 或 Spring 工具插件，则可以在 POM 编辑器中按 Ctrl + Space 并输入 “spring-boot-starter” 以获取完整列表。 如“创建您自己的 Starter”部分所述，第三方 Starter 不应以 spring-boot 开头，因为该名称保留给官方的 Spring Boot 工件。相反，第三方 Starter 通常以项目名称开头。例如，名为 thirdpartyproject 的第三方 Starter 项目通常被命名为 thirdpartyproject-spring-boot-starter。 org.springframework.boot 组下的 starters 详见： Maven Repository: org.springframework.boot 2.2. 代码结构化Spring Boot 不需要任何特定的代码布局来工作。但有一些最佳实践可以帮助。 2.2.1 不使用 “默认包”当一个类没有包声明时，它被认为是在“默认包”中。使用“默认包”通常不被推荐，应该避免使用。这可能会导致Spring Boot 应用程序使用 @ComponentScan、@ConfigurationPropertiesScan、@EntityScan或@SpringBootApplication 注释时出现问题，因为每个 jar 文件中的每个类都会被读取。 我们建议你遵循 Java 推荐的包命名规范（例如，com.example.project） 2.2.2 定位 Main 应用类我们通常建议将主应用程序类放在其他类之上的根包中。@SpringBootApplication 注释通常放在主类上，它隐式地为某些项目定义了一个基本的“搜索包”。例如，如果您正在编写一个JPA应用程序，@SpringBootApplication 注释的类的包将用于搜索@Entity项。使用根包还允许组件扫描仅适用于您的项目。 可以使用 @EnableAutoConfiguration 和 @ComponentScan 注解来替代 @SpringBootApplication 注解。 2.3 配置类Spring Boot 更青睐于基于 Java 的配置。虽然使用 XML 配置也是可行的，但我们通常建议你的主要配置源是一个单独的 @Configuration 类。通常情况下，定义 main 方法的类是作为主要 @Configuration 的一个好选择。 2.3.1 导入其他配置类您不需要将所有的 @Configuration 放在一个类中。可以使用 @Import 注解导入其他的配置类。另外，您也可以使用 @ComponentScan 来自动扫描所有的 Spring 组件，包括 @Configuration 类。 2.3.2 导入 XML 配置如果您一定要使用基于 XML 的配置，我们建议您仍然从一个 @Configuration 类开始。然后，您可以使用@ImportResource 注解来加载XML配置文件。 2.4 自动配置Spring Boot 的自动配置会尝试根据你添加的 jar 依赖自动配置你的 Spring 应用程序。例如，如果 HSQLDB 在你的类路径中，并且你没有手动配置任何数据库连接 bean，那么 Spring Boot 会自动配置一个内存数据库。 你需要通过将 @EnableAutoConfiguration 或 @SpringBootApplication 注解添加到其中一个@Configuration类中来选择自动配置。 建议您只添加一个@SpringBootApplication或@EnableAutoConfiguration注解。 一般在 main 应用类上添加 @SpringBootApplication 注解来开启自动配置。 2.4.1 替换自动配置自动配置是无侵入性的。在任何时候，您都可以开始定义自己的配置来替换自动配置的特定部分。例如，如果您添加了自己的 DataSource bean，则默认的内嵌式数据库支持会撤消。如果您需要查找当前正在应用哪些自动配置以及为什么，请在启动应用程序时使用 –debug 开关。这样做会为一组核心日志记录器启用调试日志，并将条件报告记录到控制台。 2.4.2 禁用特定的自动配置如果你不想要某些自动配置类，可以使用 @SpringBootApplication 的 exclude 属性来禁用它们，如下面的例子： 12345678import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })public class MyApplication {} 如果您更喜欢使用 @EnableAutoConfiguration 而不是 @SpringBootApplication，则也可以使用 exclude 属性。最后，您还可以使用 spring.autoconfigure.exclude 属性控制要排除的自动配置类列表。 你可以在注解级别和使用属性级别（配置类）上定义需要排除的自动配置。 自动配置类虽然是 public 的，但其公共 API 仅限于类名，可用于禁用自动配置。这些类的实际内容（如嵌套的配置类或bean方法）仅供内部使用，我们不建议直接使用这些内容。 2.5. Spring Beans 与依赖注入你可以自由地使用标准的 Spring Framework 技术来定义你的 bean 和它们注入的依赖关系。我们通常建议使用构造函数注入来连接依赖关系，并使用 @ComponentScan 查找 bean。 如果你按照上述建议组织你的代码（将应用程序类放在顶层包中），你可以添加不带任何参数的 @ComponentScan，或者使用隐式包含它的 @SpringBootApplication 注解。所有应用程序组件（@Component、@Service、@Repository、@Controller 等）都会自动注册为 Spring Beans。 以下示例展示了一个@Service Bean，它使用构造函数注入来获取所需的RiskAssessor bean： 1234567891011121314import org.springframework.stereotype.Service;@Servicepublic class MyAccountService implements AccountService { private final RiskAssessor riskAssessor; public MyAccountService(RiskAssessor riskAssessor) { this.riskAssessor = riskAssessor; } // ... } 如果一个 bean 有多个构造函数，你需要使用 @Autowired 注解标注你希望 Spring 使用的构造函数： 12345678910111213141516171819202122232425import java.io.PrintStream;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class MyAccountService implements AccountService { private final RiskAssessor riskAssessor; private final PrintStream out; @Autowired public MyAccountService(RiskAssessor riskAssessor) { this.riskAssessor = riskAssessor; this.out = System.out; } public MyAccountService(RiskAssessor riskAssessor, PrintStream out) { this.riskAssessor = riskAssessor; this.out = out; } // ... } 使用构造函数注入时，注意到 riskAssessor 字段被标记为 final ，表示它不能被后续更改。 2.6. 使用 @SpringBootApplication 注解摸了，详见 使用 @SpringBootApplication 注解 2.7. 运行程序摸了，详见 运行程序。 2.8. 开发者工具Spring Boot 包含了一组额外的工具，可以使应用程序开发体验更加愉悦。spring-boot-devtools 模块可以被包含在任何项目中，以提供额外的开发时间功能。要包含 devtools 支持，请将模块依赖项添加到您的构建中，如下面的 Maven 和 Gradle 示例所示： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123dependencies { developmentOnly(&quot;org.springframework.boot:spring-boot-devtools&quot;)} 开发者工具在运行完全打包的应用程序时会自动禁用。您可以通过使用spring.devtools.restart.enabled 系统属性来控制此行为。为了启用 devtools，无论用于启动应用程序的类加载器如何，都应将 spring.devtools.restart.enabled=true 系统属性设置为true。这不应在生产环境中执行，因为运行 devtools 会存在安全风险。要禁用 devtools，请排除依赖项或设置spring.devtools.restart.enabled=false 系统属性。 将 Maven中的依赖标记为可选（optional），或在 Gradle中使用 developmentOnly 配置，可以防止将 devtools 传递应用到使用您项目的其他模块中。（Maven 中的 optional 表示这个依赖并非必须的，即使这个依赖未能被解析，Maven 也会继续构建项目，而不会报错。当其他项目依赖该项目时，可选依赖不会被传递。） 重新打包的归档文件默认不包含 devtools。如果想要使用特定的远程 devtools 功能，就需要将它包含进去。使用 Maven 插件时，将 excludeDevtools 属性设置为 false。使用 Gradle 插件时，配置任务的类路径，以包括 developmentOnly 配置。（“重新打包的归档文件”是指通过重新打包应用程序，将应用程序和所有依赖项打包到一个可执行的 JAR 或 WAR 文件中。） 重启和重载Spring Boot 提供的重启技术通过使用两个类加载器来实现。不会发生更改的类（例如来自第三方 jar 包的类）会被加载到基础类加载器中。您正在积极开发的类会被加载到重启类加载器中。当应用程序重新启动时，重启类加载器被丢弃并创建一个新的。这种方法意味着应用程序重启通常比“冷启动”快得多，因为基础类加载器已经可用且已经填充。如果您发现应用程序重启对于您的应用程序不够快或遇到了类加载问题，您可以考虑使用重载技术。这些技术通过重写加载的类使它们更容易重新加载。 2.8.1. 诊断类加载问题重启功能是通过使用两个类加载器实现的。对于大多数应用程序，这种方法很好用。然而，在多模块项目中，它有时会导致类加载问题。为了诊断这些类加载问题是否确实是由 devtools 和其两个类加载器引起的，请尝试禁用重启功能。如果这解决了你的问题，请自定义重启类加载器以包括整个项目。 2.8.2. 属性默认值Spring Boot 支持的多个库使用缓存来提高性能，例如模板引擎缓存编译后的模板文件以避免重复解析模板文件。此外，当提供静态资源时，Spring MVC 可以添加 HTTP 缓存标头以提高响应速度。虽然缓存在生产环境中非常有益，但在开发过程中可能会产生相反的效果，阻止您查看刚刚对应用程序所做的更改。因此，spring-boot-devtools 默认禁用缓存选项。 缓存选项通常由应用程序属性文件中的设置进行配置。例如，Thymeleaf 提供了 spring.thymeleaf.cache 属性。spring-boot-devtools 模块会自动应用合理的开发时配置，而无需手动设置这些属性。 要查看由 devtools 应用的完整属性列表，请参阅：DevToolsPropertyDefaultsPostProcessor 如果您不希望应用属性默认值，可以在您的 application.properties 文件中设置 spring.devtools.add-properties 为 false。 2.8.3 自动重启使用 spring-boot-devtools 的应用程序在类路径上的文件更改时会自动重启。当在 IDE 中工作时，这是一个非常有用的特性，因为它可以为代码更改提供非常快的反馈循环。默认情况下，类路径上指向目录的任何条目都会被监视以进行更改。请注意，某些资源，例如静态资源和视图模板，更改时不需要重新启动应用程序。 详细内容请参阅：自动重启 2.8.4 热部署spring-boot-devtools 模块包含一个内置的热部署服务器，可用于在更改资源时触发浏览器刷新。 以下是 IDEA 配置热部署的操作。 为了能够文件更改时触发热部署，自动重启必须启用。 同时只能运行一个热部署服务器。在启动应用程序之前，请确保没有其他热部署服务器在运行。如果从您的IDE启动多个应用程序，则只有第一个应用程序具有热部署支持。 2.8.5 全局设置您可以通过在 $HOME/.config/spring-boot 目录下添加以下任何文件来配置全局 devtools 设置： spring-boot-devtools.properties spring-boot-devtools.yaml spring-boot-devtools.yml 添加到这些文件中的任何属性都适用于在您的计算机上使用 devtools 的所有 Spring Boot 应用程序。 2.8.6 远程应用摸了，详见 远程应用","link":"/2023/05/08/Developing-with-Spring-Boot/"},{"title":"Getting Started","text":"Chapter 1. Getting Started如果您想开始使用 Spring Boot 或者 Spring 框架，可以从阅读这一部分开始。 这一部分回答了一些基本的“是什么？”，“怎么做？”和“为什么？”的问题。其中包括 Spring Boot 的介绍以及安装指南。我们还会带您一步一步构建您的第一个Spring Boot应用程序，并在此过程中讨论一些核心原则。 1.1. Spring Boot 介绍Spring Boot 可以帮助您创建独立的、生产级别的基于 Spring 的应用程序，并使其运行。我们对 Spring 平台和第三方库有着一种有主见的看法，以便您可以尽可能轻松地开始。大多数 Spring Boot 应用程序只需要很少的 Spring 配置。 您可以使用 Spring Boot 创建可通过 java -jar 或更传统的war部署方式启动的 Java 应用程序。我们还提供了一个可以运行 “Spring脚本” 的命令行工具。 我们的主要目标是：• 为所有 Spring 开发提供根本不同的、更快速和广泛可访问的入门体验。• 默认情况下有一定的主见，但是当需求开始与默认值分歧时，尽快离开• 提供一系列对大量项目共通的非功能特性（如嵌入式服务器、安全、度量、健康检查和外部化配置）。• 完全没有代码生成，也不需要 XML 配置。 1.2. 系统要求Spring Boot 2.7.11 需要 Java 8，并且兼容Java 20及以下版本。还需要Spring Framework 5.3.27或以上版本。 以下构建工具提供了明确的构建支持： Build Tool Version Maven 3.5+ Gradle 6.8.x, 6.9.x, 7.x, and 8.x 1.2.1 Servlet 容器Spring Boot支持以下嵌入式Servlet容器： Name Servlet Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Jetty 10.0 4.0 Undertow 2.0 4.0 您还可以将 Spring Boot 应用程序部署到任何 Servlet 3.1 或 4.0 兼容的容器中。 4.3. 安装 Spring Boot略 4.4. 搭建第一个 Spring Boot 应用此处使用 IDEA 的 Spring Initializr 来构建 Spring Boot 项目。 可以选择 Spring Boot 版本与诸多依赖，此处仅选择 web 进行演示。 项目根目录下生成了一个 artifactId + Application 命名规则的入口类。 123456789101112@RestController@SpringBootApplicationpublic class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } @RequestMapping(&quot;/&quot;) public String SayHello() { return &quot;hello spring&quot;; }} 访问 http://localhost:8080，浏览器将会返回 “hello spring”。 虽然这里的代码不多，但是背后发生了很多事情。接下来的几个部分中，我们会逐步介绍重要的部分。 @RestController and @RequestMapping 注解MyApplication 类上的第一个注释是 @RestController。它为阅读代码和 Spring 提供提示，表明该类具有特定的作用。在这种情况下，我们的类是一个 web @Controller，因此当处理传入的 web 请求时，Spring 会考虑它。 @RequestMapping 注解提供“路由”信息。它告诉 Spring 任何具有 / 路径的HTTP请求都应映射到 SayHello方法。@RestController 注解告诉 Spring 将生成的字符串直接返回给调用者。 @RestController 和 @RequestMapping 注解是 Spring MVC 注解（它们不是Spring Boot特有的） 我们在（…）会讨论注解的更多细节 @SpringBootApplication Annotation第二个类级别的注解是 @SpringBootApplication。此注解被称为元注解，它结合 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan 注解。我们最感兴趣的注解是 @EnableAutoConfiguration。 @EnableAutoConfiguration 告诉 Spring Boot 根据您添加的 jar 依赖项“猜测”您想如何配置 Spring。由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，因此自动配置会假定您正在开发 Web 应用程序并相应地配置 Spring。 自动配置旨在与 “Starter” 很好地配合使用，但两个概念并不直接相关。您可以自由的选择 Starter 之外的 jar 依赖项。Spring Boot仍会尽其所能自动配置您的应用程序。 我们在（…）讨论了自动配置的更多细节 “main” 方法 我们应用程序的最后一部分是 main 方法。这是遵循 Java 应用程序入口点约定的标准方法。 我们的 main 方法通过调用 Spring Boot 的 SpringApplication 类来委托。SpringApplication 引导我们的应用程序，启动 Spring，然后启动自动配置的 Tomcat Web 服务器。我们需要将 MyApplication.class 作为参数传递给 run 方法，以告诉SpringApplication 哪个是主要的 Spring 组件。args 数组也被传递以暴露任何命令行参数。 我们在（…）讨论了 SpringApplication 的工作流程 4.5 创建可执行 Jar 包我们通过创建一个完全自包含的可执行 jar 文件来完成我们的示例，这个可执行 jar 文件可以在生产环境中运行。 在命令行中执行 mvn package，如果您查看target目录，应该会看到 myproject-0.0.1-SNAPSHOT.jar 文件。","link":"/2023/05/08/Getting-Started/"},{"title":"Core Features","text":"Chapter 3. Core Features本节将深入探讨Spring Boot的细节。您可以在这里了解您可能想要使用和自定义的关键功能。如果您尚未这样做，建议您先阅读“Getting Start”和“Developing with Spring Boot”部分，以便您对基础知识有一个良好的了解。 3.1 SpringApplicationSpringApplication 类提供了一种方便的方法来引导一个从 main() 方法启动的Spring应用程序。在许多情况下，您可以委托给静态的SpringApplication.run方法，如下例所示： 12345678@SpringBootApplicationpublic class MyApplication public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 当你的应用程序启动时，你应该看到类似于以下的输出。 12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.11)2023-04-20 07:55:04.018 INFO 17819 --- [ main] o.s.b.d.f.s.MyApplication: Starting MyApplication using Java 1.8.0_362 on myhost with PID 17819(/opt/apps/myapp.jar started by myuser in /opt/apps/)2023-04-20 07:55:04.028 INFO 17819 --- [ main] o.s.b.d.f.s.MyApplication: No active profile set, falling back to 1 default profile: &quot;default&quot;2023-04-20 07:55:07.537 INFO 17819 --- [ main]o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080(http)2023-04-20 07:55:07.549 INFO 17819 --- [ main]o.apache.catalina.core.StandardService : Starting service [Tomcat]2023-04-20 07:55:07.550 INFO 17819 --- [ main]org.apache.catalina.core.StandardEngine : Starting Servlet engine: [ApacheTomcat/9.0.74]2023-04-20 07:55:07.677 INFO 17819 --- [ main]o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embeddedWebApplicationContext2023-04-20 07:55:07.678 INFO 17819 --- [ main]w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initializationcompleted in 3520 ms2023-04-20 07:55:09.061 INFO 17819 --- [ main]o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) withcontext path ''2023-04-20 07:55:09.098 INFO 17819 --- [ main] o.s.b.d.f.s.MyApplication: Started MyApplication in 6.665 seconds (JVM running for 8.178)","link":"/2023/05/09/Core-Features/"},{"title":"Leetcode DP 0-1 背包问题","text":"0-1 背包基础有 n 件物品和一个最多能背重量为 w 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品只能拿一次，求解将哪些物品装入背包里物品价值总和最大。 例题背包最大重量为4。 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 二维数组 确定 dp 数组以及下标的含义：**dp[i][j] 表示从下标为 0-i 的物品里任意取，放进容量为j的背包，价值总和最大是多少**。 非常神秘但实用的定义，需要好好理解。 确定递推公式： dp[i][j] 有两种可能 不放下标为 i 的物品：dp[i][j] = d[i-1][j]（放不下了或放下后价值总和反而减少） 放如下标为 i 的物品：dp[i][j] = d[i-1][j-weight[i]] + value[i] dp 数组初始化： 当背包重量为 0，背包价值总和肯定为零 =&gt; dp[i][0] = 0 i = 0 时，当 j &lt; weight[0] 时，背包放不下 =&gt; dp[0][j] = 0，否则 dp[0][j] = value[0] 确定遍历顺序：遍历物品和背包重量均可，前者比较符合逻辑 举例推导 dp 数组： 先物品再重量 =&gt; 在当前重量 1.不能放下 2.放下后价值减少 3.放下后价值增加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BagProblem { public static void main(String[] args) { int[] weight = {1,3,4}; int[] value = {15,20,30}; int bagSize = 4; testWeightBagProblem(weight,value,bagSize); } /** * 动态规划获得结果 * @param weight 物品的重量 * @param value 物品的价值 * @param bagSize 背包的容量 */ public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){ // 创建dp数组 int goods = weight.length; // 获取物品的数量 int[][] dp = new int[goods][bagSize + 1]; // 初始化dp数组 // 创建数组后，其中默认的值就是0 for (int j = weight[0]; j &lt;= bagSize; j++) { dp[0][j] = value[0]; } // 填充dp数组 for (int i = 1; i &lt; weight.length; i++) { for (int j = 1; j &lt;= bagSize; j++) { if (j &lt; weight[i]) { /** * 当前背包的容量都没有当前物品i大的时候，是不放物品i的 * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值 */ dp[i][j] = dp[i-1][j]; } else { /** * 当前背包的容量可以放下物品i * 那么此时分两种情况： * 1、不放物品i * 2、放物品i * 比较这两种情况下，哪种背包中物品的最大价值最大 */ dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]); } } } }} 滚动数组类似于 62.不同路径，本题也可以使用滚动数组来降低空间复杂度。 再回头看看 dp[i][j] 的递推公式： 不放下标为 i 的物品：dp[i][j] = d[i-1][j]（放不下了或放下后价值总和反而减少） 放入下标为 i 的物品：dp[i][j] = d[i-1][j-weight[i]] + value[i] 在遍历中，发现可以把 dp[i-1][j] 直接覆盖到 dp[i][j] 上，因而修改为： 不放下标为 i 的物品：dp[i][j] = d[i][j]（放不下了或放下后价值总和反而减少） 放入下标为 i 的物品：dp[i][j] = d[i][j-weight[i]] + value[i] 再优化一下，直接将二维数组 dp[i][j] 转化为一维数组 dp[j]，丢掉物品这一维度 不放下标为 i 的物品：dp[j] = d[j]（放不下了或放下后价值总和反而减少） 放入下标为 i 的物品：dp[j] = d[j-weight[i]] + value[i] 初始化：显然 dp[0] = 0，其他下表因为涉及 max 对比，也同样设为 0 遍历顺序：为了不覆盖 “左上角” 的数据，从大到小倒序遍历，使得同一物品最多放入一次。 对比二维数组： 二维数组使用上一层的数据，不会产生覆盖问题，因此可以不限制遍历大小顺序 二维数组对背包和物品的遍历顺序不做限制，一维数组必须先物品再背包 12345678910111213141516171819202122public static void main(String[] args) { int[] weight = {1, 3, 4}; int[] value = {15, 20, 30}; int bagWight = 4; testWeightBagProblem(weight, value, bagWight);}public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){ int wLen = weight.length; //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值 int[] dp = new int[bagWeight + 1]; //遍历顺序：先遍历物品，再遍历背包容量 for (int i = 0; i &lt; wLen; i++){ for (int j = bagWeight; j &gt;= weight[i]; j--){ dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } //打印dp数组 for (int j = 0; j &lt;= bagWeight; j++){ System.out.print(dp[j] + &quot; &quot;); }} 416. 分割等和子集 Middle给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 题解这是动态规划问题吗？ 第一种解法：先求和 sum，对 nums 进行排序后，遍历求和到 sum/2 则返回 true，否则返回 false 测试用例 [2, 2, 1, 1] =&gt; 数组不能通过排序后按需遍历来判断是否满足题意 看答案吧。 通过分析题目需要得到的信息： 背包的体积为 sum / 2 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值 背包如果正好装满，说明找到了总和为 sum / 2 的子集。 背包中每一个元素是不可重复放入。 确定 dp 数组以及下标的含义：容量为 j 的背包中物品的最大价值为 dp[j] 确定递推公式：dp[j] = d[j-weight[i]] + value[i] dp 数组初始化：除非价值出现负数，否则 dp[j] = 0 确定遍历顺序：从前往后遍历 举例推导 dp 数组： 1234567891011121314151617class Solution { public boolean canPartition(int[] nums) { int[] dp = new int[10001]; int sum = Arrays.stream(nums).sum(); for (int i = 0; i &lt; nums.length; i++) { for (int j = sum / 2; j &gt;= nums[i]; j--) { dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } int res = Arrays.stream(dp).max().getAsInt(); if (res * 2 == sum) { return true; } return false; }} 1049. 最后一块石头的重量 II Middle1049. 最后一块石头的重量 II - 力扣（Leetcode） 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例 1： 1234567输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 12输入：stones = [31,26,33,21,40]输出：5 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 题解没有石头剩下 =&gt; 分割等和子集 = ture，有石头剩下 =&gt; 等和子集 = false，需要两个子集的差最小。 只改变了 return 的内容。 123456789101112131415class Solution { public int lastStoneWeightII(int[] stones) { int[] dp = new int[10001]; int sum = Arrays.stream(stones).sum(); for (int i = 0; i &lt; stones.length; i++) { for (int j = sum / 2; j &gt;= stones[i]; j--) { dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } int res = Arrays.stream(dp).max().getAsInt(); return Math.abs(sum - res * 2); }} 494. 目标和 Middle494. 目标和 - 力扣（Leetcode） 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 示例 2： 12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 题解爬楼梯问题：目标到达第 target 阶，可以退后或前进。这样没法统计。 还是划分数组的问题，两组最终作差的差值为 target（a + b = sum, a - b = target =&gt; 2a = sum + target) 按照前面的理解，dp[j] =&gt; 最大价值，这样能够统计到次数吗？ 看答案吧。 本题的区别在于从 “装最多” 变为 “装满”，因此 dp[j] 也从最大价值变为组合的方法数。 确定 dp 数组以及下标的含义：填满 j 这么大的包，有 dp[j] 种方法 确定递推公式：dp[j] += d[j-nums[i]] 背包已有 nums[i] 时，有 dp[j-nums[i]] 种方法凑成容量为 j 的背包 凑整 dp[j] 的方法总数 = sum(dp[j-nums[i]]) 求组合的方法数都是这种思想 dp 数组初始化： dp[0] = 1 注意 target 可以为负数，因此背包大小 size = abs(sum + target) / 2 1234567891011121314151617181920212223242526class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = Arrays.stream(nums).sum(); // target过大（过小）凑不到 if (sum &lt; Math.abs(target)) return 0; // 根据算式，背包必须是偶数 if ((sum + target) % 2 != 0) return 0; int size = Math.abs(sum + target) / 2; int[] dp = new int[size + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) { for (int j = size; j &gt;= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[size]; }} 474. 一和零 Middle474. 一和零 - 力扣（Leetcode） 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 1234输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 123输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。 提示： 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 &lt;= m, n &lt;= 100 题解背包有两个重量 m 和 n，value = 1，其他同 0-1 背包 123456789101112131415161718192021222324252627class Solution { public int findMaxForm(String[] strs, int m, int n) { int len = strs.length; // 分别存 0 和 1 的个数 int[][] weights = new int[len][2]; for (int i = 0; i &lt; len; ++i) { weights[i][0] = getNum(strs[i], &quot;0&quot;); weights[i][1] = getNum(strs[i], &quot;1&quot;); } int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; len; i++) { for (int j = m; j &gt;= weights[i][0]; j--) for (int k = n; k &gt;= weights[i][1]; k--) dp[j][k] = Math.max(dp[j][k], dp[j - weights[i][0]][k - weights[i][1]] + 1); } return dp[m][n]; } private int getNum(String str, String s) { return str.length() - str.replaceAll(s, &quot;&quot;).length(); }}","link":"/2023/05/22/Leetcode-DP-0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"Leetcode DP 买卖股票问题","text":"买卖股票问题不要怕，是技术性调整 121. 买卖股票的最佳时机 Easy121. 买卖股票的最佳时机 - 力扣（Leetcode） 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^4 题解暴力循环超时了 1234567891011121314151617class Solution { public int maxProfit(int[] prices) { int len = prices.length; if (len == 1) return 0; int[] profits = new int[len - 1]; for (int i = 0; i &lt; len - 1; i++) { for (int j = i + 1; j &lt; len; j++) { profits[i] = Math.max(profits[i], prices[j] - prices[i]); } } return Arrays.stream(profits).max().getAsInt(); }} 贪心算法保存左段最小值，求差值的最大值： 1234567891011121314class Solution { public int maxProfit(int[] prices) { int low = Integer.MAX_VALUE; int result = 0; for (int i = 0; i &lt; prices.length; i++) { low = Math.min(low, prices[i]); result = Math.max(result, prices[i] - low); } return result; }} 动态规划 确定 dp 数组以及下标的含义：dp[i][0] 为持有股票所得最多现金，dp[i][1] 为不持有股票所得最多现金 确定递推公式： 第 i 天持有股票 dp[i][0] 有两种可能 第 i-1 天持有股票：dp[i][0] = dp[i-1][0] 第 i 天买入股票：dp[i][0] = -prices[i] 第 i 天不持有股票 dp[i][1] 有两种可能 第 i-1 天不持有股票：dp[i][1] = dp[i-1][1] 第 i-1 天持有股票：dp[i][1] = prices[i] + dp[i-1][0] 两种情况取最大值 dp 数组初始化： dp[0][0] = -prices[0]，dp[0][1] = 0 12345678910111213141516class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]); } return Math.max(dp[len - 1][1], 0); }} 计算时只需要当天和前一天的数据，可以用滚动数组来降低空间复杂度： 12345678910111213141516class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[2][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], -prices[i]); dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[i - 1][0]); } return Math.max(dp[(len - 1) % 2][1], 0); }} 122. 买卖股票的最佳时机 II Middle122. 买卖股票的最佳时机 II - 力扣（Leetcode） 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 题解贪心算法贪心算法的核心在于吃到所有涨幅，由于允许当天同时买入和卖出股票，这是可以做到的。 以下是正式的解释： 123456789101112class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1]; } return profit; }} 动态规划 确定 dp 数组以及下标的含义：dp[i][0] 为持有股票所得最多现金，dp[i][1] 为不持有股票所得最多现金 确定递推公式：相较于上一题仅在买入股票的收益上做出改动 第 i 天持有股票 dp[i][0] 有两种可能 第 i-1 天持有股票：dp[i][0] = dp[i-1][0] 第 i 天买入股票：dp[i][0] = dp[i-1][1] - prices[i] 第 i 天不持有股票 dp[i][1] 有两种可能 第 i-1 天不持有股票：dp[i][1] = dp[i-1][1] 第 i-1 天持有股票：dp[i][1] = prices[i] + dp[i-1][0] 两种情况取最大值 dp 数组初始化： dp[0][0] = -prices[0]，dp[0][1] = 0 这里直接给出滚动数组的实现： 123456789101112131415class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]); dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]); } return Math.max(dp[(len - 1) % 2][1], 0); }} 123. 买卖股票的最佳时机 III Hard给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 12345输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 123输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 12输入：prices = [1]输出：0 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 题解一天一共五个状态：无操作、第一次持有、第一次不持有、第二次持有、第二次不持有 确定 dp 数组以及下标的含义： dp[i][0] 为无操作最大利润 dp[i][1] 为第一次持有股票最大利润 dp[i][2] 为第一次不持有股票最大利润 dp[i][3] 为第二次持有股票最大利润 dp[i][4] 为第二次不持有股票最大利润 确定递推公式：相较于上一题仅在买入股票的收益上做出改动 第 i 天第一次持有股票 dp[i][1] 有两种可能 第 i-1 天无操作（保持满仓）：dp[i][1] = dp[i-1][1] 第 i-1 天第一次持有股票（买入股票）：dp[i][1] = -prices[i] + dp[i-1][0] 第 i 天第一次不持有股票 dp[i][2] 有两种可能 第 i-1 天无操作（保持空仓）：dp[i][2] = dp[i-1][2] 第 i-1 天第一次不持有股票（卖出股票）：dp[i][2] = prices[i] + dp[i-1][1] 第 i 天第二次持有股票 dp[i][3] 有两种可能 第 i-1 天无操作（保持满仓）：dp[i][3] = dp[i-1][3] 第 i-1 天第二次持有股票（买入股票）：dp[i][3] = -prices[i] + dp[i-1][2] 第 i 天第二次不持有股票 dp[i][4] 有两种可能 第 i-1 天无操作（保持空仓）：dp[i][4] = dp[i-1][4] 第 i-1 天第二次不持有股票（卖出股票）：dp[i][4] = prices[i] + dp[i-1][3] 以上操作均取最大值 dp 数组初始化： 第 0 天无操作：dp[0][0] = 0 第 0 天第一次（第二次）持有股票：dp[0][1] = dp[0][3] = -prices[i] 第 0 天第一次（第二次）不持有股票：dp[0][2] = dp[0][4] = 0 确定遍历顺序：从前往后遍历 1234567891011121314151617class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[len][5]; dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][1] = Math.max(dp[i - 1][1], -prices[i] + dp[i - 1][0]); dp[i][2] = Math.max(dp[i - 1][2], prices[i] + dp[i - 1][1]); dp[i][3] = Math.max(dp[i - 1][3], -prices[i] + dp[i - 1][2]); dp[i][4] = Math.max(dp[i - 1][4], prices[i] + dp[i - 1][3]); } return Math.max(dp[len - 1][4], 0); }} Interesting. 188. 买卖股票的最佳时机 IV Hard给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格，和一个整型 k 。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 123输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 1234输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 0 &lt;= k &lt;= 100 0 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 题解和 123. 买卖股票的最佳实际 III 没有本质区别，只是状态增加到了 2k + 1 种 1234567891011121314151617181920class Solution { public int maxProfit(int k, int[] prices) { int len = prices.length; int[][] dp = new int[len][2 * k + 1]; for (int i = 1; i &lt; 2 * k; i = i + 2) dp[0][i] = -prices[0]; for (int i = 1; i &lt; len; i++) { for (int j = 1; j &lt;= 2 * k; j++) { if (j % 2 != 0) { dp[i][j] = Math.max(dp[i - 1][j], -prices[i] + dp[i - 1][j - 1]); } else { dp[i][j] = Math.max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1]); } } } return Math.max(dp[len - 1][2 * k], 0); }} 309. 最佳买卖股票时机含冷冻期 Middle309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode） 给定一个整数数组 prices，其中第 prices[i] 表示第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 123输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2: 12输入: prices = [1]输出: 0 提示： 1 &lt;= prices.length &lt;= 5000 0 &lt;= prices[i] &lt;= 1000 题解本题在 122. 买卖股票的最佳时机 II - 力扣（Leetcode）的基础上限制了交易频率 在之前的炒股题中，“当天卖出股票”是被归类到“未持有股票”的状态里的，本题因为冷冻期必须剥离 确定 dp 数组以及下标的含义： dp[i][0] 为第 i 天持有股票的最大利润 dp[i][1] 为第 i 天不持有股票的最大利润且当天无操作（非冷冻期） dp[i][2] 为第 i 天不持有股票的最大利润且当天卖出了股票 dp[i][3] 为第 i 天为冷冻期 确定递推公式： 第 i 天持有股票 dp[i][0] 有两种可能 第 i-1 天持有股票：dp[i][0] = dp[i-1][0] 第 i 天买入股票且第 i-1 天是冷冻期：dp[i][0] = dp[i-1][3] - prices[i] 第 i 天买入股票且第 i-1 天不是冷冻期：dp[i][0] = dp[i-1][1] - prices[i] 第 i 天不持有股票 dp[i][1] 且当天无操作（非冷冻期） 第 i-1 天不持有股票且无操作：dp[i][1] = dp[i-1][1] 第 i-1 天处于冷冻期：dp[i][1] = dp[i-1][3] 第 i 天不持有股票的最大利润且当天卖出了股票：dp[i][2] = dp[i-1][0] + prices[i] 第 i 天处于冷冻期：dp[i][3] = dp[i-1][2] dp 数组初始化： dp[0][0] = -prices[0]，dp[0][1] = 0，dp[0][2] = 0，dp[0][3] = 0 12345678910111213141516class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[len][4]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i - 1][0], Math.max(-prices[i] + dp[i - 1][3], -prices[i] + dp[i - 1][1])); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; } return Math.max(Math.max(dp[len - 1][1], dp[len - 1][2]), dp[len - 1][3]); }} 714. 买卖股票的最佳时机含手续费 Middle给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 12345678输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 12输入：prices = [1,3,7,5,10,3], fee = 3输出：6 提示： 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104 题解本题在 122. 买卖股票的最佳时机 II - 力扣（Leetcode）的基础上，用手续费限制了交易频率，比冷冻期简单 确定 dp 数组以及下标的含义：dp[i][0] 为持有股票所得最多现金，dp[i][1] 为不持有股票所得最多现金 确定递推公式：在卖出股票时扣除手续费 第 i 天持有股票 dp[i][0] 有两种可能 第 i-1 天持有股票：dp[i][0] = dp[i-1][0] 第 i 天买入股票：dp[i][0] = dp[i-1][1] - prices[i] 第 i 天不持有股票 dp[i][1] 有两种可能 第 i-1 天不持有股票：dp[i][1] = dp[i-1][1] 第 i-1 天持有股票：dp[i][1] = prices[i] + dp[i-1][0] - fee 两种情况取最大值 dp 数组初始化： dp[0][0] = -prices[0]，dp[0][1] = 0 12345678910111213141516class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]); dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0] - fee); } return Math.max(dp[(len - 1) % 2][1], 0); }} 股票问题总结","link":"/2023/05/22/Leetcode-DP-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"},{"title":"Leetcode DP 子序列问题","text":"子序列问题找到当前下表的子序列之前子序列的关系 300. 最长递增子序列 Middle300. 最长递增子序列 - 力扣（Leetcode） 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -10^4 &lt;= nums[i] &lt;= 10^4 题解看答案吧： 确定 dp 数组以及下标的含义：dp[i] 为以 nums[i] 结尾的最长严格递增子序列长度 确定递推公式：if(nums[i] &gt; nums[j]) =&gt; dp[i] = max(dp[i], dp[j] + 1) 满足 if 时，位置 i 的最长升序子序列等于 j 从 0 到 i-1 各个位置的最长升序子序列 + 1 的最大值。 确定 dp 数组初始化：dp[i] = 1 12345678910111213141516class Solution { public int lengthOfLIS(int[] nums) { int[] dp = new int[nums.length]; Arrays.fill(dp, 1); for (int i = 0; i &lt; nums.length; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return Arrays.stream(dp).max().getAsInt(); }} 674. 最长连续递增序列 Easy674. 最长连续递增序列 - 力扣（Leetcode） 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 1234输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。 提示： 1 &lt;= nums.length &lt;= 10^4 -10^9 &lt;= nums[i] &lt;= 10^9 题解贪心算法自己写的 123456789101112131415161718class Solution { public int findLengthOfLCIS(int[] nums) { if (nums.length == 1) return 1; int res = 1; int tmp = 1; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] &gt; nums[i - 1]) { tmp++; res = Math.max(res, tmp); } else { tmp = 1; } } return res; }} 答案更工整些 1234567891011121314151617class Solution {public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; int result = 1; // 连续子序列最少也是1 int count = 1; for (int i = 1; i &lt; nums.size(); i++) { if (nums[i] &gt; nums[i - 1]) { // 连续记录 count++; } else { // 不连续，count从头开始 count = 1; } if (count &gt; result) result = count; } return result; }}; 动态规划 确定 dp 数组以及下标的含义：dp[i] 为以 nums[i] 结尾的最长连续递增子序列长度 确定递推公式：if(nums[i] &gt; nums[i-1]) =&gt; dp[i] = dp[i-1] + 1 确定 dp 数组初始化：dp[i] = 1 1234567891011class Solution { public int findLengthOfLCIS(int[] nums) { int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for (int i = 1; i &lt; len; i++) if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1; return Arrays.stream(dp).max().getAsInt(); }} 718. 最长重复子数组 Middle718. 最长重复子数组 - 力扣（Leetcode） 给两个整数数组 nums1 和 nums2 ，返回 两个数组中公共的、长度最长的子数组的长度 。 示例 1： 123输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1] 。 示例 2： 12输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]输出：5 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100 题解动态规划字符串匹配 =&gt; KMP？ 看答案吧： 确定 dp 数组以及下标的含义： 以 i-1 为下标结尾的 A 串和以 j-1 为结尾的 B 串，最长重复子数组长度为 dp[i][j] 确定递推公式：if(A[i-1] == B[j-1]) =&gt; dp[i][j] = dp[i-1][j-1] + 1 确定 dp 数组初始化：dp[i][0] = dp[0][j] = 0（默认初始化） 这里没有选择 “以 i 为下标结尾的 A 串和以 j 为结尾的 B 串，最长重复子数组长度为 dp[i][j]” 如果这样设置 dp 数组，在初始化时需要将 dp 的首行和首列进行计算（对比子数组） 123456789101112131415161718class Solution { public int findLength(int[] nums1, int[] nums2) { int[][] dp = new int[nums1.length + 1][nums2.length + 1]; int result = 0; for (int i = 1; i &lt;= nums1.length; i++) { for (int j = 1; j &lt;= nums2.length; j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } if (dp[i][j] &gt; result) result = dp[i][j]; } } return result; }} 用滚动数组降低空间复杂度，和背包问题一样需要从后往前遍历： 123456789101112131415161718192021class Solution { public int findLength(int[] nums1, int[] nums2) { int[] dp = new int[nums2.length + 1]; int result = 0; for (int i = 1; i &lt;= nums1.length; i++) { for (int j = nums2.length; j &gt;= 1; j--) { if (nums1[i - 1] == nums2[j - 1]) { dp[j] = dp[j - 1] + 1; } else { // 需要补充这一步 dp[j] = 0; } if (dp[j] &gt; result) result = dp[j]; } } return result; }} 滑动窗口仅参考 12345678910111213141516171819202122232425262728293031public int findLength(int[] A, int[] B) { return A.length &lt; B.length ? findMax(A, B) : findMax(B, A);}int findMax(int[] A, int[] B) { int max = 0; int an = A.length, bn = B.length; for(int len=1; len &lt;= an; len++) { max = Math.max(max, maxLen(A, 0, B, bn - len, len)); } for(int j=bn-an; j &gt;= 0;j--) { max = Math.max(max, maxLen(A, 0, B, j, an)); } for(int i=1;i&lt;an;i++) { max = Math.max(max, maxLen(A, i, B, 0, an - i)); } return max;}int maxLen(int[] a, int i, int[] b, int j, int len) { int count = 0, max = 0; for(int k = 0; k &lt; len; k++) { if(a[i+k] == b[j+k]) { count++; } else if(count &gt; 0) { max = Math.max(max, count); count = 0; } } return count &gt; 0 ? Math.max(max, count) : max;} 1143. 最长公共子序列 Middle1143. 最长公共子序列 - 力扣（Leetcode） 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。 示例 2： 123输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。 示例 3： 123输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0 。 提示： 1 &lt;= text1.length, text2.length &lt;= 1000 text1 和 text2 仅由小写英文字符组成。 题解 确定 dp 数组以及下标的含义： 以 i-1 为下标结尾的 A 串和以 j-1 为结尾的 B 串的最长公共子序列的长度为 dp[i][j] 确定递推公式：注意字符不相同时，需要对比的子串 A[i-1] == B[j-1] : dp[i][j] = dp[i-1][j-1] + 1 A[i-1] != B[j-1] : dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 确定 dp 数组初始化：dp[i][0] = dp[0][j] = 0（默认初始化） 12345678910111213141516171819class Solution { public int longestCommonSubsequence(String text1, String text2) { int len1 = text1.length(); int len2 = text2.length(); int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[len1][len2]; }} 1035. 不相交的线 Middle1035. 不相交的线 - 力扣（Leetcode） 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 1234输入：nums1 = [1,4,2], nums2 = [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 12输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]输出：3 示例 3： 12输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]输出：2 提示： 1 &lt;= nums1.length, nums2.length &lt;= 500 1 &lt;= nums1[i], nums2[j] &lt;= 2000 题解等价于 1143. 最长公共子序列 - 力扣（Leetcode） 12345678910111213141516171819class Solution { public int maxUncrossedLines(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } return dp[len1][len2]; }} 53. 最大子序和 Middle53. 最大子数组和 - 力扣（Leetcode） 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 题解贪心算法当序列和为负数时，此序列只能让之后的序列和减少，所以直接抛弃，把 sum 重置为 0 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int sum = 0; int max = nums[0]; for (int i = 0; i &lt; nums.length; i++) { sum += nums[i]; max = Math.max(sum, max); if (sum &lt; 0) sum = 0; } return max; }} 动态规划 确定 dp 数组以及下标的含义：dp[i] 为前 i 个元素（包含）的最大连续子序列和 确定递推公式：只有两种可能 nums[i] 加入连续子序列：dp[i] = dp[i-1] + nums[i] 以 nums[i] 为头计算连续子序列和：dp[i] = nums[i] 确定 dp 数组初始化：dp[0] = nums[0] 123456789101112class Solution { public int maxSubArray(int[] nums) { int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); return Arrays.stream(dp).max().getAsInt(); }} 392. 判断子序列 Easy392. 判断子序列 - 力扣（Leetcode） 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 示例 1： 12输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true 示例 2： 12输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false 提示： 0 &lt;= s.length &lt;= 100 0 &lt;= t.length &lt;= 10^4 两个字符串都只由小写字符组成。 题解暴力循环12345678910111213141516class Solution { public boolean isSubsequence(String s, String t) { int len1 = s.length(); int len2 = t.length(); int i = 0, j = 0; while (i &lt; len1 &amp;&amp; j &lt; len2) { if (s.charAt(i) == t.charAt(j)) i++; j++; } if (i == len1) return true; else return false; }} 动态规划判断比统计简单 1143. 最长公共子序列 - 力扣（Leetcode），区别在于只能改动长串 t 12345678910111213141516public boolean isSubsequence(String s, String t) { int len1 = s.length(); int len2 = t.length(); int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = dp[i][j - 1]; } } } return dp[len1][len2] == s.length(); } 115. 不同的子序列 Hard115. 不同的子序列 - 力扣（Leetcode） 给你两个字符串 s 和 t，统计并返回在 s 的子序列中 t 出现的个数。 题目数据保证答案符合 32 位带符号整数范围。 示例 1： 1234567输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;输出：3解释：如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。(ra)b(bbit)(rab)b(bit)(rabb)b(it) 示例 2： 123456789输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;输出：5解释：如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 (b)abgb(ag)(ba)b(g)bag(ba)bgba(g)ba(b)gb(ag)babg(bag) 提示： 1 &lt;= s.length, t.length &lt;= 1000 s 和 t 由英文字母组成 题解将长串的匹配与删除挂钩 确定 dp 数组：dp[i][j] 以 i-1 为结尾的 s 子串和以 j-1 为结尾的 t 子串，s 的子序列中 t 出现的个数。 确定递推公式：两种可能，此处的“不使用”看作删除 s[i-1] == t[j-1]： 使用 s[i-1] 进行匹配：dp[i][j] = dp[i-1][j-1] 不使用 s[i-1] 进行匹配：dp[i][j] = dp[i-1][j] 例如 s = rabb，t = rab，s[3] = t[2]，此时可以用前面一段来匹配 s[2] = t[2] s[i-1] != t[j-1]：dp[i][j] = dp[i-1][j] 确定 dp 数组初始化：根据公式需要初始化第一列和第一行 =&gt; dp[i][0] 和 dp[0][j] dp[i][0] 即以 i-1 结尾的 s 子串任意删除元素，出现空串的个数 =&gt; dp[i][0] = 1 dp[0][j] 即以空字符串出现以 t-1 结尾的子串 t 的个数 =&gt; dp[0][j] = 0 dp[0][0] = 0 1234567891011121314151617181920212223class Solution { public int numDistinct(String s, String t) { int len1 = s.length(); int len2 = t.length(); int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) { dp[i][0] = 1; } for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; } } return dp[len1][len2]; }} 583. 两个字符串的删除操作 Middle583. 两个字符串的删除操作 - 力扣（Leetcode） 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例 1： 123输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;输出: 2解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot; 示例 2: 12输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;输出：4 提示： 1 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 只包含小写英文字母 题解动态规划一 确定 dp 数组：dp[i][j] 以 i-1 为结尾的 word1 子串和以 j-1 为结尾的 word2 子串相同所需的最小步数 确定递推公式：两种可能 word1[i-1] == word2[j-1]：dp[i][j] = dp[i-1][j-1] word1[i-1] != word2[j-1]：dp[i][j] = min(dp[i-1][j] + 1，dp[i][j-1] + 1) 确定 dp 数组初始化：根据公式需要初始化第一列和第一行 =&gt; dp[i][0] 和 dp[0][j] dp[i][0] 即以 i-1 结尾的 word 子串与空串相同所需的最小步数 =&gt; dp[i][0] = i，同理 dp[0][j] = j 自己做的（笑 1234567891011121314151617181920212223242526class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) { dp[i][0] = i; } for (int i = 0; i &lt;= len2; i++) { dp[0][i] = i; } for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); } } return dp[len1][len2]; }} 答案改进 递推公式：可以两个串的元素都不保留 =&gt; dp[i-1][j-1] + 2 word1[i-1] != word2[j-1]：dp[i][j] = min(dp[i-1][j] + 1，dp[i][j-1] + 1, dp[i-1][j-1] + 2) 动态规划二本题与 1143. 最长公共子序列 - 力扣（Leetcode） 基本相同，只是递推公式从求最大值改成了最小值： A[i-1] == B[j-1] : dp[i][j] = dp[i-1][j-1] + 1 A[i-1] != B[j-1] : dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 删除最长公共子序列之外的元素即可使两字符串相同 =&gt; result = len1 + len2 - 2 * len_same 72. 编辑距离 Hard72. 编辑距离 - 力扣（Leetcode） 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 题解先补齐元素，再遍历过程中只剩替换 =&gt; ? 确定 dp 数组：dp[i][j] 以 i-1 为结尾的 word1 子串转换为 j-1 为结尾的 word2 子串所使用的最少操作数 确定递推公式： word1[i-1] == word2[j-1]：dp[i][j] = dp[i-1][j-1] word1[i-1] != word2[j-1]：dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1) 确定 dp 数组初始化： dp[i][j] = abs(i - j) 插入/删除操作，将两字符串长度调整到相等 答案对了，但是逻辑上不太对 12345678910111213141516171819202122232425class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) { for (int j = 0; j &lt;= len2; j++) { dp[i][j] = Math.abs(i - j); } } for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j] + 1, Math.min(dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1)); } } return dp[len1][len2]; }} 看看答案吧： 确定 dp 数组：dp[i][j] 以 i-1 为结尾的 word1 子串转换为 j-1 为结尾的 word2 子串所使用的最少操作数 确定递推公式： word1[i-1] == word2[j-1]：不操作 =&gt; dp[i][j] = dp[i-1][j-1] word1[i-1] != word2[j-1]：删除 word1 等价于添加 word2 word1 删除 =&gt; dp[i][j] = dp[i-1][j] + 1 word2 删除 =&gt; dp[i][j] = dp[i][j-1] + 1 替换元素 =&gt; dp[i][j] = dp[i-1][j-1] + 1 确定 dp 数组初始化： 需要初始化首行和首列：dp[i][0] = i，dp[0][j] = j 12345678910111213141516171819202122public int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; // 初始化 for (int i = 1; i &lt;= m; i++) { dp[i][0] = i; } for (int j = 1; j &lt;= n; j++) { dp[0][j] = j; } for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[m][n];} 647. 回文子串 Middle647. 回文子串 - 力扣（Leetcode） 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 123输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123输入：s = &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由小写英文字母组成 题解贪心算法123456789101112131415161718class Solution { public int countSubstrings(String s) { if (s.length() == 1) return 1; int len = s.length(); int result = 0; for (int i = 0; i &lt; len; i++) { for (int j = i + 1; j &lt;= len; j++) { String tmp = s.substring(i, j); String re_tmp = new StringBuffer(tmp).reverse().toString(); if (tmp.equals(re_tmp)) result++; } } return result; }} 动态规划 确定 dp 数组：dp[i][j] 为区间范围 [i,j] 的子串是否为回文 确定递推公式： s[i] != s[j]：dp[i][j] = false s[i] == s[j] ： i = j：dp[i][j] = true （同一个字符当然是回文） i + 1 = j：dp[i][j] = true（相邻字符相同也是回文） i + 1 &lt; j：dp[i][j] = dp[i + 1][j - 1](两端相同看中间) 确定 dp 数组初始化：dp[i][j] = false 遍历顺序：从下到上，从左到右 516. 最长回文子序列516. 最长回文子序列 - 力扣（Leetcode） 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 提示： 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 题解 确定 dp 数组：dp[i][j] 为区间范围 [i,j] 最长的回文子序列长度 确定递推公式： s[i] == s[j]：dp[i][j] = dp[i-1][j+1] + 2 s[i] != s[j] ：同时加入不会增加长度 分别添加 s[i] 和 s[j]：dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 确定 dp 数组初始化：dp[i][j] = false 遍历顺序：从下到上，从左到右","link":"/2023/05/22/Leetcode-DP-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"},{"title":"Leetcode DP 完全背包问题","text":"完全背包基础有 n 件物品和一个最多能背重量为 w 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品可以拿多次，求解将哪些物品装入背包里物品价值总和最大。 背包最大重量为4。 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 0-1 背包问题的循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： 123456// 先遍历物品，再遍历背包for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 对于完全背包问题（求最大价值）的滚动数组，两个循环的嵌套顺序是无所谓的！ 物品在外环，背包在内环的遍历： 背包在外环，物品在内环的遍历： （518）但在求装满背包有几种方案的时候，需要区分遍历顺序： 求组合数就是外层遍历物品，内层遍历背包。 求排列数就是外层遍历背包，内层遍历物品。 518. 零钱兑换 II Middle518. 零钱兑换 II - 力扣（Leetcode） 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 1234567输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 示例 2： 123输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 12输入：amount = 10, coins = [10] 输出：1 提示： 1 &lt;= coins.length &lt;= 300 1 &lt;= coins[i] &lt;= 5000 coins 中的所有值 互不相同 0 &lt;= amount &lt;= 5000 题解装满背包，求组合数。 确定 dp 数组以及下标的含义：凑成总金额为 j 的硬币组合数中为 dp[j] 确定递推公式：dp[j] += d[j-coins[i]] dp 数组初始化：dp[0] = 1 确定遍历顺序：从小到大遍历 举例推导 dp 数组： 事实上，本题限定必须先遍历物品再遍历背包 =&gt; 组合数。先背包再物品 =&gt; 排列数。 12345678910111213class Solution { public int change(int amount, int[] coins) { int len = coins.length; int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i &lt; len; i++) { for (int j = coins[i]; j &lt;= amount; j++) { dp[j] += dp[j - coins[i]]; } } return dp[amount]; }} 377. 组合总和 IV Middle377. 组合总和 Ⅳ - 力扣（Leetcode） 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 123456789101112输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。 示例 2： 12输入：nums = [9], target = 3输出：0 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 1000 nums 中的所有元素 互不相同 1 &lt;= target &lt;= 1000 进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ 题解装满背包问题，求排列数 1234567891011121314class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int j = 0; j &lt;= target; j++) { for (int i = 0; i &lt; nums.length; ++i) { if (j - nums[i] &gt;= 0) dp[j] += dp[j - nums[i]]; } } return dp[target]; }}s 70. 爬楼梯 Easy假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 题解用背包方法，就可以将步数从 {1，2} 推广到 {1，2，…，m} 装满背包问题，求排列数 123456789101112131415class Solution { public int climbStairs(int n) { int[] dp = new int[n + 1]; int[] weight = { 1, 2 }; dp[0] = 1; for (int j = 0; j &lt;= n; j++) { for (int i = 0; i &lt; weight.length; ++i) { if (j - weight[i] &gt;= 0) dp[j] += dp[j - weight[i]]; } } return dp[n]; }} 322. 零钱兑换 Middle322. 零钱兑换 - 力扣（Leetcode） 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 2^31 - 1 0 &lt;= amount &lt;= 10^4 题解第一个思路：首先要求背包价值，其次要求物品数量最少 =&gt; 双重背包分别保存价值和硬币数量 方法复杂还做不对（x) 第二个思路：只保存硬币个数 确定 dp 数组以及下标的含义：dp[j] 为凑成总金额 j 所需的最少的硬币个数 确定递推公式：dp[j] = min(dp[j], dp[j-coins[i]] + 1 dp 数组初始化： dp[0] = 0，由于递推公式需要求最小值，那么 dp[j]必须取最大值 =&gt; 事实上最多只会有 amount 个硬币，因此设 dp[j] = amount + 1 (j ≠ 0) 1234567891011121314151617class Solution { public int coinChange(int[] coins, int amount) { int len = coins.length; int[] dp = new int[amount + 1]; for (int i = 1; i &lt;= amount; i++) { dp[i] = amount + 1; } for (int i = 0; i &lt; len; i++) { for (int j = coins[i]; j &lt;= amount; j++) { dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); } } return dp[amount] &gt; amount ? -1 : dp[amount]; }} 279. 完全平方数 Middle279. 完全平方数 - 力扣（Leetcode） 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 10^4 题解本质和 322. 零钱兑换相同，区别在于完全平方数 weights 需要自己计算。 确定 dp 数组以及下标的含义：dp[j] 为和为 j 的完全平方数的最少数量 确定递推公式：dp[j] = min(dp[j], dp[j-weights[i]] + 1 dp 数组初始化： dp[0] = 0，由于递推公式需要求最小值，那么 dp[j]必须取最大值 =&gt; 事实上最多只会有 n 个硬币，因此设 dp[j] = n + 1 (j ≠ 0) 123456789101112131415161718192021222324252627282930313233class Solution { public int numSquares(int n) { ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); int tmp = 1; while (tmp &lt;= n) { if (isSquare(tmp)) arr.add(tmp); tmp++; } int len = arr.size(); int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { dp[i] = n + 1; } for (int i = 0; i &lt; len; i++) { for (int j = arr.get(i); j &lt;= n; j++) { dp[j] = Math.min(dp[j], dp[j - arr.get(i)] + 1); } } return dp[n] &gt; n ? -1 : dp[n]; } private boolean isSquare(int n) { for (int i = 1; n &gt; 0; i += 2) n -= i; return n == 0; }} 答案的思路，不需要判断是否为平方数： 1234567891011121314151617181920class Solution { public int numSquares(int n) { int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; //初始化 for (int j = 0; j &lt;= n; j++) { dp[j] = max; } // 遍历物品 for (int i = 1; i * i &lt;= n; i++) { // 遍历背包 for (int j = i * i; j &lt;= n; j++) { if (dp[j - i * i] != max) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } } return dp[n]; }} 139. 单词拆分 Middle139. 单词拆分 - 力扣（Leetcode） 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 提示： 1 &lt;= s.length &lt;= 300 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 20 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中的所有字符串 互不相同 题解字符串怎么比对？ 答案： 确定 dp 数组以及下标的含义：dp[j] = true 即字符串长度为 j 时可以被拆分为多个单词 确定递推公式：if(s.substring(i, j) 在字典里 &amp;&amp; dp[i] == ture) =&gt; dp[j] = true dp 数组初始化： dp[0] = true 确定遍历顺序：注意单词必须有序，因此需要求排列数 =&gt; 先背包后物品 本题的关键在于分析谁是“物品”，有别于传统题目提供数组作为物品，本题将字串作为物品进行分析。 1234567891011121314151617class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { int len = s.length(); // HashSet 实现查找功能 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(wordDict); boolean[] dp = new boolean[len + 1]; dp[0] = true; for (int j = 1; j &lt;= len; j++) { for (int i = 0; i &lt; j &amp;&amp; !dp[j]; i++) if (set.contains(s.substring(i, j)) &amp;&amp; dp[i]) dp[j] = true; } return dp[len]; }}","link":"/2023/05/22/Leetcode-DP-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"Leetcode DP 基础","text":"代码随想录 (programmercarl.com) 动态规划动态规划问题五步走： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 509. 斐波那契数 Easy509. 斐波那契数 - 力扣（Leetcode） 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 示例 1： 123输入：n = 2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：n = 3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：n = 4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 题解 确定 dp 数组以及下标的含义：第 i 个数的斐波那契数值是 dp[i] 确定递推公式：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2] 已给出 dp 数组初始化：dp[0] = 0，dp[1] = 1 已给出 确定遍历顺序：从前往后遍历 举例推导 dp 数组：斐波那契数 [0 1 1 2 3 5 8 13 21 34 55] 递归1234567891011class Solution { public int fib(int n) { if(n == 0) { return 0; } else if (n == 1) { return 1; } else { return fib(n - 1) + fib (n - 2); } }} 循环12345678910111213class Solution { public int fib(int n) { if (n &lt; 2) return n; int a = 0, b = 1, c = 0; for (int i = 1; i &lt; n; i++) { c = a + b; a = b; b = c; } return c; }} 70. 爬楼梯 Easy假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 题解本质上就是斐波那契数。 确定 dp 数组以及下标的含义： dp[i] 为爬到第 i 阶的方法数 确定递推公式：每次爬一阶或两阶 =&gt; dp[i] = dp[i-1] + dp[i-2] dp 数组初始化：dp[1] = 1，dp[2] = 2 确定遍历顺序：从前往后遍历 举例推导 dp 数组 递归算到 n = 45 直接超时。 123456789class Solution { public int climbStairs(int n) { if (n == 1 || n == 2) { return n; } else { return climbStairs(n - 1) + climbStairs(n - 2); } }} 循环12345678910111213class Solution { public int climbStairs(int n) { if (n &lt;= 2) return n; int a = 1, b = 2, c = 0; for (int i = 3; i &lt;= n; i++) { c = a + b; a = b; b = c; } return c; }} 进阶每次你可以爬 1 或 2 个台阶 =&gt; 1 ~ m 个台阶。 后面再来求解。 746. 使用最小花费爬楼梯 Easy746. 使用最小花费爬楼梯 - 力扣（Leetcode） 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 示例 1： 12345输入：cost = [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。 示例 2： 12345678910输入：cost = [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。 提示： 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999 题解 确定 dp 数组以及下标的含义：dp[i] 为到达第 i 阶需要的最小开销 确定递推公式：dp[i] = min(dp[i-1] + cost[i-1]，dp[i-2] + cost[i-2]) dp 数组如何初始化：dp[0] = 0，dp[1] = 0 确定遍历顺序：从前往后遍历 cost 举例推导dp数组：…… 基础版本： 1234567891011class Solution { public int minCostClimbingStairs(int[] cost) { int length = cost.length; int[] dp = new int[length + 1]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= cost.length; i++) dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); return dp[length]; }} 实际上只用到两个dp，可以将空间复杂度从O(n)降到O(1) 123456789101112class Solution { public int minCostClimbingStairs(int[] cost) { int dp0 = 0; int dp1 = 0; for (int i = 2; i &lt;= cost.size(); i++) { int dpi = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); dp0 = dp1; // 记录一下前两位 dp1 = dpi; } return dp1; }}; 62. 不同路径 Middle一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10^9 题解 确定 dp 数组以及下标的含义：dp[i][j] 为到达该位置的方法数 确定递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] （注意边界） dp 数组初始化：dp[0][0] = 0; 确定遍历顺序： 举例推导 dp数组 动态规划12345678910111213141516class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; dp[0][0] = 1; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } } } return dp[m - 1][n - 1]; }} 使用滚动数组来优化空间： 1234567891011121314151617class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; for (int i = 0; i &lt; n; i++) { dp[0] = 1; } for (int j = 1; j &lt; m; j++) { for (int i = 1; i &lt; n; i++) { dp[i] += dp[i - 1]; } } return dp[n - 1]; }} 这里的优化方案如图所示: 数论无论哪种走法，到达终点都需要 m+n-2 步，其中 m-1 向下，n-1 向右。 到底有几种走法？=&gt; 排列组合问题 $C^{m-1}_{m+n-2}$ 为防止数值溢出，在运算中不能直接将分子分母都乘出来。 12345678910111213141516class Solution { int uniquePaths(int m, int n) { long numerator = 1; // 分子 int denominator = m - 1; // 分母 int count = m - 1; int t = m + n - 2; while (count-- &gt; 0) { numerator *= (t--); while (denominator != 0 &amp;&amp; numerator % denominator == 0) { numerator /= denominator; denominator--; } } return (int) numerator; }} 63. 不同路径 II Middle63. 不同路径 II - 力扣（Leetcode） 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 题解本题是 62.不同路径 的推广，需要注意一些细节问题： 障碍物 dp[i][j] = 0 初始化时若障碍物在第一行/第一列，障碍物后的也要置零。 1234567891011121314151617181920212223242526272829class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if (obstacleGrid[0][0] == 1) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; dp[0][0] = 1; for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] != 1; i++) { dp[i][0] = 1; } for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] != 1; j++) { dp[0][j] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] != 1) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; }} （题外话：True dude） 96. 不同的二叉搜索树 Middle96. 不同的二叉搜索树 - 力扣（Leetcode） 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 12输入：n = 3输出：5 示例 2： 12输入：n = 1输出：1 提示： 1 &lt;= n &lt;= 19 题解直接抄吧。 确定 dp 数组以及下标的含义：dp[i] 为 1 到 i 结点组成的二叉搜索树的数量 确定递推公式：dp[i] += dp[j-1] * dp[i-j]，其中 j-1 为左子树结点数量，i-j为右子树结点数量 dp 数组初始化：dp[0] = 1，dp[0] 空树也是树！ 确定遍历顺序： 举例推导 dp 数组： 1234567891011121314151617class Solution { public int numTrees(int n) { if (n == 1 || n == 2) return n; int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { dp[i] += dp[i - j] * dp[j - 1]; } } return dp[n]; }}","link":"/2023/05/17/Leetcode-DP-%E5%9F%BA%E7%A1%80/"},{"title":"Leetcode DP 总结","text":"动态规划总结篇 动态规划基础背包问题0-1 背包完全背包打家劫舍买卖股票子序列","link":"/2023/05/23/Leetcode-DP-%E6%80%BB%E7%BB%93/"},{"title":"Leetcode DP 打家劫舍问题","text":"打家劫舍问题盗亦有道 198. 打家劫舍 Middle198. 打家劫舍 - 力扣（Leetcode） 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 题解在 0-1 背包求最大价值的基础上，限制了连续取物品，如何标记和更新取物品的标记？ 普通的爬楼梯问题，没有背包了。 答案： 确定 dp 数组以及下标的含义：dp[i] 为前面 i 间房（包含 i) 能偷盗的最大金额 确定递推公式：偷不偷第 i 间房？ 偷：dp[i] = dp[i - 2] + nums[i] 不偷：dp[i] = dp[i - 1] 由此得出公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) dp 数组初始化： dp[0] = nums[0]，dp[1] = max(nums[0], nums[1]) 1234567891011121314151617class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 1) return nums[0]; int[] dp = new int[len + 1]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; len; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[len - 1]; }} 213. 打家劫舍 II Middle213. 打家劫舍 II - 力扣（Leetcode） 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 1234输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 12输入：nums = [1,2,3]输出：3 题解相较于 198. 打家劫舍，数组现在成环了。 答案： 仅改变遍历的内容，其他逻辑不变： 包含首元素不包含尾元素：1 -&gt; nums.len - 1 不包含首元素包含尾元素：0 -&gt; nums.len - 2 123456789101112131415161718192021222324252627class Solution { public int rob(int[] nums) { int len = nums.length; if (len &lt;= 3) return Arrays.stream(nums).max().getAsInt(); int res1 = range(nums, 0, len - 2); int res2 = range(nums, 1, len - 1); return Math.max(res1, res2); } public int range(int[] nums, int start, int end) { int len = nums.length; int[] dp = new int[len]; dp[start] = nums[start]; dp[start + 1] = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[end]; }} 337. 打家劫舍 III Middle337. 打家劫舍 III - 力扣（Leetcode） 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例 1: 123输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2: 123输入: root = [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 提示： 树的节点数在 [1, 10^4] 范围内 0 &lt;= Node.val &lt;= 10^4 题解从数组变为二叉树 递归超时了 1234567891011121314151617181920class Solution { public int rob(TreeNode root) { if (root == null) return 0; if (root.left == null &amp;&amp; root.right == null) return root.val; // 偷该结点 int val1 = root.val; if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right); if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right); // 不偷该节点 int val2 = rob(root.left) + rob(root.right); return Math.max(val1, val2); }} 动态规划本题的难点在于如何记录偷得金钱的数值，如何构造 dp 数组 答案： ，需要一个长度为 2 的数组 确定 dp 数组以及下标的含义：要求记录节点在偷与不偷两个状态所获得的金钱 =&gt; dp[0] &amp; dp[1] 这里并没有保存结点本身，因为保存节点没有意义，在树的遍历中依靠递归来传值 确定递推公式： 偷父节点：val1 = root.val + left[1] + right[1] 不偷父节点：val2 = max(left[0],left[1]) + max(right[0],right[1]) 确定遍历顺序：后序遍历（需要得到左孩子和右孩子的数组，判断父节点偷不偷） 12345678910111213141516171819class Solution { public int rob(TreeNode root) { int[] result = robTree(root); return (Math.max(result[0], result[1])); } int[] robTree(TreeNode root) { int res[] = new int[2]; if (root == null) return res; int[] left = robTree(root.left); int[] right = robTree(root.right); res[0] = root.val + left[1] + right[1]; res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); return res; }}","link":"/2023/05/22/Leetcode-DP-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/"},{"title":"Leetcode 哈希表","text":"代码随想录 (programmercarl.com) 理论基础当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 LeetCode242. 有效的字母异位词 Easy242. 有效的字母异位词 - 力扣（Leetcode） 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: $1 &lt;= s.length, t.length &lt;= 5 * 104$ $s 和 t 仅包含小写字母$ 题解注意：char 类型字符可以以 ASCII 数进行相减。 123456789101112131415161718public boolean isAnagram(String s, String t) { if (s.length() != t.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s.length(); ++i) record[s.charAt(i) - 'a']++; for (int i = 0; i &lt; t.length(); ++i) { record[t.charAt(i) - 'a']--; for (int i = 0; i &lt; 26; i++) if (record[i] != 0) return false; return true;} 进阶如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ Hash solution with unicode follow-ups - Valid Anagram - LeetCode Leetcode 242 Valid Anagram | For Unicode characters | Hindi - YouTube 使用哈希表将所有字符映射到整型中，再进行比较。 349. 两个数组的交集 Easy349. 两个数组的交集 - 力扣（Leetcode） 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 提示： $1 &lt;= nums1.length, nums2.length &lt;= 1000$ $0 &lt;= nums1[i], nums2[i] &lt;= 1000$ 题解1234567891011121314151617181920public int[] intersection(int[] nums1, int[] nums2) { HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); HashSet&lt;Integer&gt; res = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; nums1.length; ++i) set.add(nums1[i]); for (int i = 0; i &lt; nums2.length; ++i) if (set.contains(nums2[i])) res.add(nums2[i]); int arr[] = new int[res.size()]; int j = 0; for (int i : res) arr[j++] = i; return arr;} 202. 快乐数 Easy202. 快乐数 - 力扣（Leetcode） 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 示例 2： 12输入：n = 2输出：false 提示： $1 &lt;= n &lt;= 2^{31} - 1$ 题解无限循环指运算过程中数值的循环，而非循环函数的无限执行 Happy number - Wikipedia =&gt; 快乐数的原理未知，只需要知道输入的值经过计算可能得到以下三种结果： 最终会得到 1 =&gt; true 最终会进入循环 =&gt; false 值会越来越大，最后接近无穷大。 第三种情况事实上不会发生，对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。 4 位或 4 位以上的数字在运算中总会降到 3 位为止。 Digits Largest Next 1 9 81 2 99 162 3 999 243 4 9999 324 13 9999999999999 1053 解法1记录每一步的数值，注意取余数的计算方法。 123456789101112131415161718192021class Solution { public boolean isHappy(int n) { HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); while (n != 1 &amp;&amp; !set.contains(n)) { set.add(n); n = calNextNum(n); } return n == 1; } public int calNextNum(int n) { int res = 0; while (n &gt; 0) { int tmp = n % 10; res += tmp * tmp; n /= 10; } return res; }} 解法2类比链表成环，利用快慢指针法找到环的起点或快指针到达 1。 弗洛伊德的兔子与乌龟(Floyd’s Tortoise and Hare algorithm) - 知乎 (zhihu.com) 注意快慢指针的写法： 慢指针走一步，判断是否达到终止条件 快指针在慢指针基础上走一步 循环判断，慢指针一步快指针两步 本题慢指针走一步不会达到终止条件，因此可以跳过第一步。 123456789101112131415161718192021222324252627class Solution { public boolean isHappy(int n) { int slow = calNextNum(n); // if (slow == 1) // return true; int fast = calNextNum(slow); while (fast != slow &amp;&amp; fast != 1) { fast = calNextNum(fast); slow = calNextNum(slow); if (fast != 1) fast = calNextNum(fast); } return fast == 1; } public int calNextNum(int n) { int res = 0; while (n &gt; 0) { int tmp = n % 10; res += tmp * tmp; n /= 10; } return res; }} 1. 两数之和 Easy1. 两数之和 - 力扣（LeetCode） 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： $2 &lt;= nums.length &lt;= 10^4$ $-10^9 &lt;= nums[i] &lt;= 10^9$ $-10^9 &lt;= target &lt;= 10^9$ 只会存在一个有效答案 题解灵活使用哈希表，从而避免 $O(n^2)$ 的开销。 map用来做什么 用来存放访问过的元素。遍历数组的时候，需要记录之前遍历过的元素和对应下标，才能找到与当前元素相匹配的值。 map中key和value分别表示什么 判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。 这里用值做 key，而用 index 做 value。因为题目需要返回 index，而 map 只能通过 key 来获取 value。 123456789101112131415161718class Solution { public int[] twoSum(int[] nums, int target) { int[] arr = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int minus = target - nums[i]; if (map.containsKey(minus)) { arr[0] = i; arr[1] = map.get(minus); break; } map.put(nums[i], i); } return arr; }} 454. 四数相加 II Middle454. 四数相加 II - 力扣（LeetCode） 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 1234567输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示： n == nums.length 1 &lt;= n &lt;= 200 -2^{28} &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^{28} 题解使用四个循环暴力求解 100% 超时。 这道题需要返回次数，那么出现的次数就作为 value，而需要对比的值作为 key。 前两个数组用来统计数值之和 tmp 及其出现次数，放入 map 后两个数组计算数值之和 tmp 后查找 map 的 key 是否存在 -tmp，存在则 res += value。 12345678910111213141516171819202122232425262728class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; int temp; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i : nums1) { for (int j : nums2) { temp = i + j; if (map.containsKey(temp)) map.replace(temp, map.get(temp) + 1); else map.put(temp, 1); } } for (int i : nums3) { for (int j : nums4) { temp = i + j; if (map.containsKey(-temp)) res += map.get(-temp); } } return res; }} 383. 赎金信 Easy给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 10^5 ransomNote 和 magazine 由小写英文字母组成 题解又是只有小写字符，这题的解法同 242. 有效的字母异位词。注意数组的开销要小于哈希表。 12345678910111213141516171819class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] record = new int[26]; for (int i = 0; i &lt; magazine.length(); ++i) record[magazine.charAt(i) - 'a']++; for (int i = 0; i &lt; ransomNote.length(); ++i) record[ransomNote.charAt(i) - 'a']--; for (int i = 0; i &lt; 26; i++) if (record[i] &lt; 0) return false; return true; }} 15. 三数之和 Middle15. 三数之和 - 力扣（Leetcode） 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 题解本题是 1. 两数之和的推广，且要求三数不同 =&gt; target 藏到 nums 中了。 使用哈希表求解遇到的最大困难是三元组去重问题，需要将流程从无序变成有序，较为复杂。 去重是指不重复的三元组，三元组内是允许存在重复元素的。去重的逻辑是连续两轮的数值相同时跳过。 改用双指针法： 将输入数组进行排序（本题返回数值而非索引，因而可以这样操作） 定义 i 从 0 开始，left 在 i + 1，right 在 length - 1 =&gt; a = nums[i]，b = nums[left]，c = nums[right] 因为是有序数组，当 a + b + c &lt; 0 时，left 向右移动，当 a + b + c &gt; 0 时，right 向左移动。 当 left == right 时退出循环 该方法的时间复杂度为 O(n^2) 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); // a=nums[i], b=nums[left], c=nums[right] for (int i = 0; i &lt; nums.length; i++) { // 最小的元素大于零时无解 if (nums[i] &gt; 0) return res; // 对a的去重，若nums[i-1] == nums[i]，这两轮结果会相同 // 如果向前判断 nums[i] == nums[i+1]，则会丢掉三元组内元素相同的解，如{-1, -1, 2} if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1; int right = nums.length - 1; while (left &lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum &gt; 0) { right--; } else if (sum &lt; 0) { left++; } else { res.add(Arrays.asList(nums[i], nums[left], nums[right])); // right去重 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; // left去重 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return res; }} 18. 四数之和 Middle18. 四数之和 - 力扣（Leetcode） 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 题解本体是 15. 三数之和的推广，四元组且给定 target。 第一个想法是在三数之和的基础上新增一个循环，让 a=nums[i]，b=nums[j]，c=nums[left]，d=nums[right]。 于是有了第一版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); // a=nums[i], b=nums[j], c=nums[left], d=nums[right] for (int i = 0; i &lt; nums.length; i++) { if (nums[i] &gt; target) { return res; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &lt; nums.length; j++) { if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) { continue; } int left = j + 1; int right = nums.length - 1; while (left &lt; right) { int sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum &gt; target) { right--; } else if (sum &lt; target) { left++; } else { res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // right去重 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } // left去重 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } right--; left++; } } } } return res; }} 返回了错误信息： 排序得到 [-5, -4, -3, -2, 1, 3, 3, 5]，a = -5，target = -11 直接跳出了循环，因此得不到结果 这表明在负数 target 情况下，去重不能简单使用 nums[i] &gt; target，进行如下修改： 123if (nums[i] &gt; target &amp;&amp; target &gt; 0) { return res;} 返回了错误信息： 非常罕见的情况，四个值相加直接溢出得到了负数 target，从而产生了输出。 尝试在 Answer 插入 List 前打补丁，结果遗憾超时。 1if (nums[right] &gt; sum) 这表明上一步的去重不应该限制 target，转而限制 nums[i]，结果通过。 123if (nums[i] &gt; target &amp;&amp; nums[i] &gt; 0) { return res;} 总结来源：https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html 数组作为哈希表一些应用场景就是为数组量身定做的。 在 242.有效的字母异位词 中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！ 这道题目包含小写字母，那么使用数组来做哈希最合适不过。 在 383.赎金信 中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！ 本题和 242.有效的字母异位词 很像，242.有效的字母异位词 是求 字符串a 和 字符串b 是否可以相互组成，在 383.赎金信 中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。 一些同学可能想，用数组干啥，都用map不就完事了。 上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！ set作为哈希表在 349. 两个数组的交集 中我们给出了什么时候用数组就不行了，需要用set。 这道题目没有限制数值的大小，就无法使用数组来做哈希表了。 主要因为如下两点： 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。 所以此时一样的做映射的话，就可以使用set了。 map作为哈希表在 1.两数之和 中map正式登场。 来说一说：使用数组和set来做哈希法的局限。 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 map是一种&lt;key, value&gt;的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。 在 454.四数相加 中我们提到了其实需要哈希的地方都能找到map的身影。 本题咋眼一看好像和 18. 四数之和 ，15.三数之和 差不多，其实差很多！ 关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而 18. 四数之和，15.三数之和 是一个数组（集合）里找到和为0的组合，可就难很多了！ 用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。 其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。 在 15.三数之和 中我给出了哈希法和双指针两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。 所以18. 四数之和，15.三数之和都推荐使用双指针法！","link":"/2023/05/14/Leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"Leetcode 回溯算法","text":"","link":"/2023/05/24/Leetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"title":"Leetcode-字符串","text":"来源：代码随想录 (programmercarl.com) Leetcode344. 反转字符串 Easy344. 反转字符串 - 力扣（Leetcode） 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 1： 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 提示： 1 &lt;= s.length &lt;= 10^5 s[i] 都是 ASCII 码表中的可打印字符 题解普通的数组反转。 1234567891011121314class Solution { public void reverseString(char[] s) { int l = 0; int r = s.length - 1; while (l &lt; r) { // 异或操作实现交换 s[l] ^= s[r]; s[r] ^= s[l]; s[l] ^= s[r]; l++; r--; } }} 541. 反转字符串 II Easy541. 反转字符串 II - 力扣（Leetcode） 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2： 12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 10^4 s 仅由小写英文组成 1 &lt;= k &lt;= 10^4 题解翻译题目要求： 划分字符串，每 2k 个字符一组，反转组内前 k 个字符。 最后一组若字符数少于 k 个，则全部反转，若字符数少于 2k 个，则反转前 k 个字符。 当需要固定规律一段一段去处理字符串的时候，在for循环的表达式上做文章。 123456789101112131415161718192021222324252627class Solution { public String reverseStr(String s, int k) { // String-&gt;char 以实现随机访问 char[] ch = s.toCharArray(); // 每一步覆盖2k个字符 for (int i = 0; i &lt; s.length(); i += 2 * k) { int start = i; // 只有最后一段会出现字符数不足的情况 int end = Math.min(s.length() - 1, start + k - 1); reverseString(ch, start, end); } return new String(ch); } public void reverseString(char[] ch, int l, int r) { while (l &lt; r) { // 异或操作实现交换 ch[l] ^= ch[r]; ch[r] ^= ch[l]; ch[l] ^= ch[r]; l++; r--; } }} 剑指 Offer 05. 替换空格 Easy请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 12输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 10 &lt;= s 的长度 &lt;= 10000 题解解法1Java 用到 StringBuilder，逐字扫描即可。 123456789101112131415161718public static String replaceSpace(String s) { if (s == null) { return null; } //选用 StringBuilder 单线程使用，比较快，选不选都行 StringBuilder sb = new StringBuilder(); //使用 sb 逐个复制 s ，碰到空格则替换，否则直接复制 for (int i = 0; i &lt; s.length(); i++) { //s.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型 //if (&quot; &quot;.equals(String.valueOf(s.charAt(i)))){} if (s.charAt(i) == ' ') { sb.append(&quot;%20&quot;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } 解法2先检查字符串的空格数量，对数组进行扩容后使用双指针法。 123456789101112131415161718192021222324252627282930313233public String replaceSpace(String s) { if(s == null || s.length() == 0){ return s; } //扩充空间，空格数量2倍 StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) { if(s.charAt(i) == ' '){ str.append(&quot; &quot;); } } //若是没有空格直接返回 if(str.length() == 0){ return s; } //有空格情况 定义两个指针 int left = s.length() - 1;//左指针：指向原始字符串最后一个位置 s += str.toString(); int right = s.length()-1;//右指针：指向扩展字符串的最后一个位置 char[] chars = s.toCharArray(); while(left&gt;=0){ if(chars[left] == ' '){ chars[right--] = '0'; chars[right--] = '2'; chars[right] = '%'; }else{ chars[right] = chars[left]; } left--; right--; } return new String(chars);} 151. 反转字符串中的单词 Middle给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 1： 12输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot; 示例 2： 123输入：s = &quot; hello world &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3： 123输入：s = &quot;a good example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 &lt;= s.length &lt;= 10^4 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 题解解法1使用 split 按照划分字符串，定义新字符串后将单词倒序相加，需要额外空间复杂度 O(n) 进阶就地反转字符串 -&gt; 数组的反转（整体反转 -&gt; 部分反转） 清理原字符串的多余空格 整个字符串反转 每个单词反转 123456public String reverseWords(String s) { StringBuilder sb = removeSpace(s); reverseString(sb, 0, sb.length() - 1); reverseEachWord(sb); return sb.toString();} 清理空格： 123456789101112131415161718192021public StringBuilder removeSpace(String s) { int start = 0; int end = s.length() - 1; // 去除前后的多余空格 while (s.charAt(start) == ' ') start++; while (s.charAt(end) == ' ') end--; StringBuilder sb = new StringBuilder(); while (start &lt;= end) { char c = s.charAt(start); // c不是空格，或c是空格且sb最后插入的内容不是空格 if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } start++; } return sb; } 反转字符串，注意交换时使用 sb.setCharAt(index, char) 123456789public void reverseString(StringBuilder sb, int start, int end) { while (start &lt; end) { char tmp = sb.charAt(start); sb.setCharAt(start, sb.charAt(end)); sb.setCharAt(end, tmp); start++; end--; }} 双指针法，当 end 走到空格时， start 到 end - 1 为一个单词，反转单词后 end + 1 又是下一个词的开始。 12345678910111213public void reverseEachWord(StringBuilder sb) { int start = 0; int end = start + 1; int n = sb.length(); while (start &lt; n) { while (end &lt; n &amp;&amp; sb.charAt(end) != ' ') { end++; } reverseString(sb, start, end - 1); start = end + 1; end = start + 1; }} 剑指 Offer 58-II 左旋转字符串剑指 Offer 58 - II. 左旋转字符串 - 力扣（Leetcode） 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例 1 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 示例 2： 12输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot; 限制： 1 &lt;= k &lt; s.length &lt;= 10000 题解前段反转，后段反转，最后整体反转。 123456789101112131415161718class Solution { public String reverseLeftWords(String s, int n) { int len=s.length(); StringBuilder sb=new StringBuilder(s); reverseString(sb,0,n-1); reverseString(sb,n,len-1); return sb.reverse().toString(); } public void reverseString(StringBuilder sb, int start, int end) { while (start &lt; end) { char temp = sb.charAt(start); sb.setCharAt(start, sb.charAt(end)); sb.setCharAt(end, temp); start++; end--; } }} 28. 实现 strStr() Middle28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode） 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 1： 1234输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。 示例 2： 123输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。 提示： 1 &lt;= haystack.length, needle.length &lt;= 104 haystack 和 needle 仅由小写英文字符组成 题解本题是经典的 KMP 算法，内容参考： 图解kmp算法-通俗易懂kmp算法 - 简书 (jianshu.com) KMP 算法详解 - 知乎 (zhihu.com) 全网最通俗的KMP算法图解 - 知乎 (zhihu.com) 简单来说，需要根据模式串计算 next 数组（前缀和后缀公共部分的最大长度） 计算 next 数组的过程 初始化： 定义指针 i -&gt; 后缀末尾， j -&gt; 前缀末尾，规定 next[0] = -1，next[i] 表示 i 之前最长相等的前后缀长度 规定 i 从 1 开始，j 从 -1 开始，进行 s[i] 与 s[j + 1] 的对比 前后缀不相同的情况 如果是 s[1] != s[0]，显然没有公共前缀，next[i] = j（next[1] = -1） s[i] != s[j + 1]，需要找 next[j] 前后缀相同的情况 i 和 j (j + 1) 同时向后移动 12345678910111213141516private void getNext(int[] next, String s) { int j = -1; next[0] = j; // 核心 for (int i = 1; i &lt; s.length(); i++) { // 若前后缀不相等 while (j &gt;= 0 &amp;&amp; s.charAt(j + 1) != s.charAt(i)) j = next[j]; // 前后缀相同 if (s.charAt(j + 1) == s.charAt(i)) j++; next[i] = j; } } 使用 next 数组进行匹配 初始化： 定义指针 i = 0 指向文本串起始位置，j = -1 指向模式串起始位置 ​ 其余部分与 计算过程相同 1234567891011121314151617181920212223242526public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; // 遍历文本串 for (int i = 0; i &lt; haystack.length(); i++) { // 不匹配 while (j &gt;= 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j + 1)) j = next[j]; if (haystack.charAt(i) == needle.charAt(j + 1)) { j++; } if (j + 1 == needle.length()) return i - needle.length() + 1; } return -1; } 459. 重复的子字符串 Easy?459. 重复的子字符串 - 力扣（Leetcode） 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 123输入: s = &quot;abab&quot;输出: true解释: 可由子串 &quot;ab&quot; 重复两次构成。 示例 2: 12输入: s = &quot;aba&quot;输出: false 示例 3: 123输入: s = &quot;abcabcabcabc&quot;输出: true解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。) 提示： 1 &lt;= s.length &lt;= 10^4 s 由小写英文字母组成 题解枚举遍历字串的长度。 1234567891011121314151617181920class Solution { public boolean repeatedSubstringPattern(String s) { int n = s.length(); for (int i = 1; i * 2 &lt;= n; ++i) { if (n % i == 0) { boolean match = true; for (int j = i; j &lt; n; ++j) { if (s.charAt(j) != s.charAt(j - i)) { match = false; break; } } if (match) { return true; } } } return false; }} 匹配我们将两个 s 连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s 就满足题目要求。 12345class Solution { public boolean repeatedSubstringPattern(String s) { return (s + s).indexOf(s, 1) != s.length(); }} KMP如何找到模式？最长相等前后缀不包含的子串就是最小重复子串。 简单推理 假设字符串 s 使用多个重复子串（最小重复单位）构成，重复出现的子字符串长度是 x，有 s.length = n * x。 字符串 s 的最长相同前后缀的长度一定不包含 s 本身，最长相同前后缀长度必然是 m * x，且 n - m = 1 若 nx % (n - m)x = 0 =&gt; n % (n - m) = 0，就可以判定有重复出现的子字符串 其中 m = next[s.length - 1] + 1 123456789101112public boolean repeatedSubstringPattern(String s) { int n = s.length(); int[] next = new int[s.length()]; next = getNext(s, next); if (next[n - 1] != -1 &amp;&amp; n % (n - (next[n - 1] + 1)) == 0) { return true; } return false; }","link":"/2023/05/16/Leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"Leetcode 数组","text":"数组基础704. 二分查找 Easy704. 二分查找 - 力扣（Leetcode） 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 题解闭区间写法 123456789101112131415161718class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0, right = len - 1; int mid; while (left &lt;= right) { mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; } return -1; }} 左闭右开区间写法 123456789101112131415class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left &lt; right) { int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid; } return -1; }} 27. 移除元素 Easy27. 移除元素 - 力扣（Leetcode） 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 题解暴力循环从后往前遍历，从前往后搬运 123456789101112131415class Solution { public int removeElement(int[] nums, int val) { int len = nums.length; int result = len; for (int i = len - 1; i &gt;= 0; i--) { if (nums[i] == val) { result--; for (int j = i + 1; j &lt; len; j++) { nums[j - 1] = nums[j]; } } } return result; }} 双指针法 12345678910111213class Solution { public int removeElement(int[] nums, int val) { // 快慢指针 int slowIndex = 0; for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) { if (nums[fastIndex] != val) { nums[slowIndex] = nums[fastIndex]; slowIndex++; } } return slowIndex; }} 977. 有序数组的平方 Easy977. 有序数组的平方 - 力扣（Leetcode） 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 题解暴力循环123456789class Solution { public int[] sortedSquares(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { nums[i] *= nums[i]; } Arrays.sort(nums); return nums; }} 双指针法数组平方的最大值在原数组的两端，因此可以使用双指针法 123456789101112131415161718class Solution { public int[] sortedSquares(int[] nums) { int right = nums.length - 1; int left = 0; int[] result = new int[nums.length]; int index = result.length - 1; while (left &lt;= right) { if (nums[left] * nums[left] &gt; nums[right] * nums[right]) { result[index--] = nums[left] * nums[left]; ++left; } else { result[index--] = nums[right] * nums[right]; --right; } } return result; }} 209. 长度最小的子数组 Easy209. 长度最小的子数组 - 力扣（Leetcode） 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 题解滑动窗口真得好好学 12345678910111213141516171819202122class Solution { public int minSubArrayLen(int target, int[] nums) { if (nums[0] &gt;= target) return 1; int len = nums.length; int sum = 0; int res = Integer.MAX_VALUE; int left = 0; for (int right = 0; right &lt; len; right++) { sum += nums[right]; // 核心，这里的 while 让 i 一直更新 while (sum &gt;= target) { res = Math.min(res, right - left + 1); sum -= nums[left++]; } } return res == Integer.MAX_VALUE ? 0 : res; }} 59. 螺旋矩阵 II Middle59. 螺旋矩阵 II - 力扣（Leetcode） 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 题解抄答案吧： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public int[][] generateMatrix(int n) { int loop = 0; // 控制循环次数 int[][] res = new int[n][n]; int start = 0; // 每次循环的开始点(start, start) int count = 1; // 定义填充数字 int i, j; while (loop++ &lt; n / 2) { // 判断边界后，loop从1开始 // 模拟上侧从左到右 for (j = start; j &lt; n - loop; j++) { res[start][j] = count++; } // 模拟右侧从上到下 for (i = start; i &lt; n - loop; i++) { res[i][j] = count++; } // 模拟下侧从右到左 for (; j &gt;= loop; j--) { res[i][j] = count++; } // 模拟左侧从下到上 for (; i &gt;= loop; i--) { res[i][j] = count++; } start++; } if (n % 2 == 1) { res[start][start] = count; } return res; }}","link":"/2023/05/23/Leetcode-%E6%95%B0%E7%BB%84/"},{"title":"Leetcode 栈与队列","text":"栈与队列简单了解。 232. 用栈实现队列 Easy232. 用栈实现队列 - 力扣（Leetcode） 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 1： 12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 提示： 1 &lt;= x &lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 题解放元素的时候扔 StackIn，弹元素时如果 StackOut 非空就弹，否则先把 StackIn 扔进 StackOut 后再弹 12345678910111213141516171819202122232425262728293031323334353637class MyQueue { Stack&lt;Integer&gt; stackIn; Stack&lt;Integer&gt; stackOut; public MyQueue() { stackIn = new Stack&lt;&gt;(); // 负责进栈 stackOut = new Stack&lt;&gt;(); // 负责出栈 } public void push(int x) { stackIn.push(x); } public int pop() { dumpstackIn(); return stackOut.pop(); } public int peek() { dumpstackIn(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty(); } private void dumpstackIn() { if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } }} 225. 用队列实现栈 Easy225. 用队列实现栈 - 力扣（Leetcode） 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例： 12345678910111213输入：[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False 提示： 1 &lt;= x &lt;= 9 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 进阶：你能否仅用一个队列来实现栈。 题解两个队列实现： 一个队列实现： 在入队新元素时，把队中元素全部出队再重新入队，就成为栈了 12345678910111213141516171819202122232425262728class MyStack { Queue&lt;Integer&gt; queue; public MyStack() { queue = new LinkedList&lt;&gt;(); } public void push(int x) { queue.offer(x); int size = queue.size(); // 移动除了 A 的其它数 while (size-- &gt; 1) queue.offer(queue.poll()); } public int pop() { return queue.poll(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); }} 20. 有效的括号 Easy20. 有效的括号 - 力扣（Leetcode） 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]{}&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 '()[]{}' 组成 题解括号匹配，遇到左括号入栈相应的右括号，遇到右括号弹栈，对比元素即可。Stack类已经过时，Java 官方推荐使用Deque替代Stack使用。 三种情况返回 false： 元素还有，栈空了 元素没了，栈没空 左右括号不匹配 1234567891011121314151617181920212223class Solution { public boolean isValid(String s) { Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;(); char ch; for (int i = 0; i &lt; s.length(); i++) { ch = s.charAt(i); // 碰到左括号，就把相应的右括号入栈 if (ch == '(') { deque.push(')'); } else if (ch == '{') { deque.push('}'); } else if (ch == '[') { deque.push(']'); } else if (deque.isEmpty() || deque.peek() != ch) { return false; } else {// 如果是右括号判断是否和栈顶元素匹配 deque.pop(); } } // 最后判断栈中元素是否匹配 return deque.isEmpty(); }} 150. 逆波兰表达式求值 Middle150. 逆波兰表达式求值 - 力扣（Leetcode） 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 '+'、'-'、'*' 和 '/' 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1： 123输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 123输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 12345678910输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i] 是一个算符（&quot;+&quot;、&quot;-&quot;、&quot;*&quot; 或 &quot;/&quot;），或是在范围 [-200, 200] 内的一个整数 题解","link":"/2023/05/23/Leetcode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"title":"Leetcode 链表","text":"链表基础203. 移除链表元素 Easy203. 移除链表元素 - 力扣（Leetcode） 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 题解自己写的，对头节点的判断写的很烂： 1234567891011121314151617181920212223class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; while (head.val == val) { head = head.next; if (head == null) return null; } ListNode result = head; while (head.next != null) { if (head.next.val == val) head.next = head.next.next; else { head = head.next; } } return result; }} 答案写的好看些： 12345678910111213public ListNode removeElements(ListNode head, int val) { while(head!=null &amp;&amp; head.val==val){ head = head.next; } ListNode curr = head; while(curr!=null){ while(curr.next!=null &amp;&amp; curr.next.val == val){ curr.next = curr.next.next; } curr = curr.next; } return head;} 707. 设计链表 Middle707. 设计链表 - 力扣（Leetcode） 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例： 1234567891011121314输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 题解开抄 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181class ListNode { int val; ListNode next; ListNode(){} ListNode(int val) { this.val=val; }}class MyLinkedList { //size存储链表元素的个数 int size; //虚拟头结点 ListNode head; //初始化链表 public MyLinkedList() { size = 0; head = new ListNode(0); } //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点 public int get(int index) { //如果index非法，返回-1 if (index &lt; 0 || index &gt;= size) { return -1; } ListNode currentNode = head; //包含一个虚拟头节点，所以查找第 index+1 个节点 for (int i = 0; i &lt;= index; i++) { currentNode = currentNode.next; } return currentNode.val; } //在链表最前面插入一个节点，等价于在第0个元素前添加 public void addAtHead(int val) { addAtIndex(0, val); } //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加 public void addAtTail(int val) { addAtIndex(size, val); } // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果 index 大于链表的长度，则返回空 public void addAtIndex(int index, int val) { if (index &gt; size) { return; } if (index &lt; 0) { index = 0; } size++; //找到要插入节点的前驱 ListNode pred = head; for (int i = 0; i &lt; index; i++) { pred = pred.next; } ListNode toAdd = new ListNode(val); toAdd.next = pred.next; pred.next = toAdd; } //删除第index个节点 public void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= size) { return; } size--; if (index == 0) { head = head.next; return; } ListNode pred = head; for (int i = 0; i &lt; index ; i++) { pred = pred.next; } pred.next = pred.next.next; }}//双链表class ListNode{ int val; ListNode next,prev; ListNode() {}; ListNode(int val){ this.val = val; }}class MyLinkedList { //记录链表中元素的数量 int size; //记录链表的虚拟头结点和尾结点 ListNode head,tail; public MyLinkedList() { //初始化操作 this.size = 0; this.head = new ListNode(0); this.tail = new ListNode(0); //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！ head.next=tail; tail.prev=head; } public int get(int index) { //判断index是否有效 if(index&lt;0 || index&gt;=size){ return -1; } ListNode cur = this.head; //判断是哪一边遍历时间更短 if(index &gt;= size / 2){ //tail开始 cur = tail; for(int i=0; i&lt; size-index; i++){ cur = cur.prev; } }else{ for(int i=0; i&lt;= index; i++){ cur = cur.next; } } return cur.val; } public void addAtHead(int val) { //等价于在第0个元素前添加 addAtIndex(0,val); } public void addAtTail(int val) { //等价于在最后一个元素(null)前添加 addAtIndex(size,val); } public void addAtIndex(int index, int val) { //index大于链表长度 if(index&gt;size){ return; } //index小于0 if(index&lt;0){ index = 0; } size++; //找到前驱 ListNode pre = this.head; for(int i=0; i&lt;index; i++){ pre = pre.next; } //新建结点 ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next.prev = newNode; newNode.prev = pre; pre.next = newNode; } public void deleteAtIndex(int index) { //判断索引是否有效 if(index&lt;0 || index&gt;=size){ return; } //删除操作 size--; ListNode pre = this.head; for(int i=0; i&lt;index; i++){ pre = pre.next; } pre.next.next.prev = pre; pre.next = pre.next.next; }} 206. 反转链表 Easy给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 题解双指针法就地逆置 12345678910111213class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; }} 递归法while 循环改成递归 123456789101112131415class Solution { public ListNode reverseList(ListNode head) { return reverse(null, head); } private ListNode reverse(ListNode prev, ListNode cur) { if (cur == null) { return prev; } ListNode temp = null; temp = cur.next; cur.next = prev; return reverse(cur, temp); }} 24. 两两交换链表结点 Middle24. 两两交换链表中的节点 - 力扣（Leetcode） 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 题解看答案吧： 递归方法1234567891011121314class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; // 让后段进行交换 ListNode newNode = swapPairs(next.next); next.next = head; head.next = newNode; return next; }} 非递归方法作图，构造头节点 1234567891011121314151617181920class Solution { public ListNode swapPairs(ListNode head) { ListNode dummyhead = new ListNode(-1); // 设置一个虚拟头结点 dummyhead.next = head; // 将虚拟头结点指向head，这样方面后面做删除操作 ListNode cur = dummyhead; ListNode temp; // 临时节点，保存两个节点后面的节点 ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点 ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点 while (cur.next != null &amp;&amp; cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } return dummyhead.next; }} 19. 删除链表的倒数第 N 个结点 Middle19. 删除链表的倒数第 N 个结点 - 力扣（Leetcode） 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 题解快慢指针法，但是最好构建一个头节点，便于处理首元结点的逻辑 1234567891011121314151617181920212223class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (head.next == null &amp;&amp; n == 1) return null; ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; for (int i = 0; i &lt; n; i++) { fastIndex = fastIndex.next; } while (fastIndex.next != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } slowIndex.next = slowIndex.next.next; return dummyNode.next; }} 160. 相交链表 Easy给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 题解12345678910111213public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; }} 142. 环形链表 II Middle142. 环形链表 II - 力扣（Leetcode） 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ 题解快慢指针 1234567891011public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null || slow != fast) { slow = slow.next; fast = fast.next; if (fast.next != null) fast = fast.next; } }}","link":"/2023/05/23/Leetcode-%E9%93%BE%E8%A1%A8/"},{"title":"Mall 订单模块分析","text":"订单管理分析数据库表总览 订单管理表格订单详情表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748create table oms_order( id bigint not null auto_increment comment '订单id', member_id bigint not null comment '会员id', coupon_id bigint comment '优惠券id', order_sn varchar(64) comment '订单编号', create_time datetime comment '提交时间', member_username varchar(64) comment '用户帐号', total_amount decimal(10,2) comment '订单总金额', pay_amount decimal(10,2) comment '应付金额（实际支付金额）', freight_amount decimal(10,2) comment '运费金额', promotion_amount decimal(10,2) comment '促销优化金额（促销价、满减、阶梯价）', integration_amount decimal(10,2) comment '积分抵扣金额', coupon_amount decimal(10,2) comment '优惠券抵扣金额', discount_amount decimal(10,2) comment '管理员后台调整订单使用的折扣金额', pay_type int(1) comment '支付方式：0-&gt;未支付；1-&gt;支付宝；2-&gt;微信', source_type int(1) comment '订单来源：0-&gt;PC订单；1-&gt;app订单', status int(1) comment '订单状态：0-&gt;待付款；1-&gt;待发货；2-&gt;已发货；3-&gt;已完成；4-&gt;已关闭；5-&gt;无效订单', order_type int(1) comment '订单类型：0-&gt;正常订单；1-&gt;秒杀订单', delivery_company varchar(64) comment '物流公司(配送方式)', delivery_sn varchar(64) comment '物流单号', auto_confirm_day int comment '自动确认时间（天）', integration int comment '可以获得的积分', growth int comment '可以活动的成长值', promotion_info varchar(100) comment '活动信息', bill_type int(1) comment '发票类型：0-&gt;不开发票；1-&gt;电子发票；2-&gt;纸质发票', bill_header varchar(200) comment '发票抬头', bill_content varchar(200) comment '发票内容', bill_receiver_phone varchar(32) comment '收票人电话', bill_receiver_email varchar(64) comment '收票人邮箱', receiver_name varchar(100) not null comment '收货人姓名', receiver_phone varchar(32) not null comment '收货人电话', receiver_post_code varchar(32) comment '收货人邮编', receiver_province varchar(32) comment '省份/直辖市', receiver_city varchar(32) comment '城市', receiver_region varchar(32) comment '区', receiver_detail_address varchar(200) comment '详细地址', note varchar(500) comment '订单备注', confirm_status int(1) comment '确认收货状态：0-&gt;未确认；1-&gt;已确认', delete_status int(1) not null default 0 comment '删除状态：0-&gt;未删除；1-&gt;已删除', use_integration int comment '下单时使用的积分', payment_time datetime comment '支付时间', delivery_time datetime comment '发货时间', receive_time datetime comment '确认收货时间', comment_time datetime comment '评价时间', modify_time datetime comment '修改时间', primary key (id)); 订单商品表12345678910111213141516171819202122232425262728create table oms_order_item( id bigint not null auto_increment, order_id bigint comment '订单id', order_sn varchar(64) comment '订单编号', product_id bigint comment '商品id', product_pic varchar(500) comment '商品图片', product_name varchar(200) comment '商品名称', product_brand varchar(200) comment '商品品牌', product_sn varchar(64) comment '商品条码', product_price decimal(10,2) comment '销售价格', product_quantity int comment '购买数量', product_sku_id bigint comment '商品sku编号', product_sku_code varchar(50) comment '商品sku条码', product_category_id bigint comment '商品分类id', sp1 varchar(100) comment '商品的销售属性1', sp2 varchar(100) comment '商品的销售属性2', sp3 varchar(100) comment '商品的销售属性3', promotion_name varchar(200) comment '商品促销名称', promotion_amount decimal(10,2) comment '商品促销分解金额', coupon_amount decimal(10,2) comment '优惠券优惠分解金额', integration_amount decimal(10,2) comment '积分优惠分解金额', real_amount decimal(10,2) comment '该商品经过优惠后的分解金额', gift_integration int not null default 0 comment '商品赠送积分', gift_growth int not null default 0 comment '商品赠送成长值', product_attr varchar(500) comment '商品销售属性:[{&quot;key&quot;:&quot;颜色&quot;,&quot;value&quot;:&quot;颜色&quot;},{&quot;key&quot;:&quot;容量&quot;,&quot;value&quot;:&quot;4G&quot;}]', primary key (id)); 订单操作记录表12345678910create table oms_order_operate_history( id bigint not null auto_increment, order_id bigint comment '订单id', operate_man varchar(100) comment '操作人：用户；系统；后台管理员', create_time datetime comment '操作时间', order_status int(1) comment '订单状态：0-&gt;待付款；1-&gt;待发货；2-&gt;已发货；3-&gt;已完成；4-&gt;已关闭；5-&gt;无效订单', note varchar(500) comment '备注', primary key (id)); 后台订单列表 订单详情 业务订单列表Create后台当然不能直接创建订单，找找创建的接口吧。 Update12345678910@ApiOperation(&quot;批量发货&quot;)@RequestMapping(value = &quot;/update/delivery&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delivery(@RequestBody List&lt;OmsOrderDeliveryParam&gt; deliveryParamList) { int count = orderService.delivery(deliveryParamList); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 12345678910@ApiOperation(&quot;批量关闭订单&quot;)@RequestMapping(value = &quot;/update/close&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult close(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam String note) { int count = orderService.close(ids, note); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 12345678910@ApiOperation(&quot;修改收货人信息&quot;)@RequestMapping(value = &quot;/update/receiverInfo&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateReceiverInfo(@RequestBody OmsReceiverInfoParam receiverInfoParam) { int count = orderService.updateReceiverInfo(receiverInfoParam); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 12345678910@ApiOperation(&quot;修改订单费用信息&quot;)@RequestMapping(value = &quot;/update/moneyInfo&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateReceiverInfo(@RequestBody OmsMoneyInfoParam moneyInfoParam) { int count = orderService.updateMoneyInfo(moneyInfoParam); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 123456789101112@ApiOperation(&quot;备注订单&quot;)@RequestMapping(value = &quot;/update/note&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateNote(@RequestParam(&quot;id&quot;) Long id, @RequestParam(&quot;note&quot;) String note, @RequestParam(&quot;status&quot;) Integer status) { int count = orderService.updateNote(id, note, status); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Read 查询订单123456789@ApiOperation(&quot;查询订单&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;OmsOrder&gt;&gt; list(OmsOrderQueryParam queryParam, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;OmsOrder&gt; orderList = orderService.list(queryParam, pageSize, pageNum); return CommonResult.success(CommonPage.restPage(orderList));} 1234567@ApiOperation(&quot;获取订单详情：订单信息、商品信息、操作记录&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;OmsOrderDetail&gt; detail(@PathVariable Long id) { OmsOrderDetail orderDetailResult = orderService.detail(id); return CommonResult.success(orderDetailResult);} Delete12345678910@ApiOperation(&quot;批量删除订单&quot;)@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = orderService.delete(ids); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 订单设置12345678910create table oms_order_setting( id bigint not null auto_increment, flash_order_overtime int comment '秒杀订单超时关闭时间(分)', normal_order_overtime int comment '正常订单超时时间(分)', confirm_overtime int comment '发货后自动确认收货时间（天）', finish_overtime int comment '自动完成交易时间，不能申请售后（天）', comment_overtime int comment '订单完成后自动好评时间（天）', primary key (id)); Update12345678910@ApiOperation(&quot;修改指定订单设置&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @RequestBody OmsOrderSetting orderSetting) { int count = orderSettingService.update(id,orderSetting); if(count&gt;0){ return CommonResult.success(count); } return CommonResult.failed();} Read1234567@ApiOperation(&quot;获取指定订单设置&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;OmsOrderSetting&gt; getItem(@PathVariable Long id) { OmsOrderSetting orderSetting = orderSettingService.getItem(id); return CommonResult.success(orderSetting);} 退货订单处理Update12345678910@ApiOperation(&quot;修改退货申请状态&quot;)@RequestMapping(value = &quot;/update/status/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateStatus(@PathVariable Long id, @RequestBody OmsUpdateStatusParam statusParam) { int count = returnApplyService.updateStatus(id, statusParam); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Read123456789@ApiOperation(&quot;分页查询退货申请&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;OmsOrderReturnApply&gt;&gt; list(OmsReturnApplyQueryParam queryParam, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;OmsOrderReturnApply&gt; returnApplyList = returnApplyService.list(queryParam, pageSize, pageNum); return CommonResult.success(CommonPage.restPage(returnApplyList));} 1234567@ApiOperation(&quot;获取退货申请详情&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult getItem(@PathVariable Long id) { OmsOrderReturnApplyResult result = returnApplyService.getItem(id); return CommonResult.success(result);} Delete12345678910@ApiOperation(&quot;批量删除退货申请&quot;)@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = returnApplyService.delete(ids); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 退货原因设置Create12345678910@ApiOperation(&quot;添加退货原因&quot;)@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@RequestBody OmsOrderReturnReason returnReason) { int count = orderReturnReasonService.create(returnReason); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Update12345678910@ApiOperation(&quot;修改退货原因&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @RequestBody OmsOrderReturnReason returnReason) { int count = orderReturnReasonService.update(id, returnReason); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 1234567891011@ApiOperation(&quot;修改退货原因启用状态&quot;)@RequestMapping(value = &quot;/update/status&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateStatus(@RequestParam(value = &quot;status&quot;) Integer status, @RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = orderReturnReasonService.updateStatus(ids, status); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Read12345678@ApiOperation(&quot;分页查询退货原因&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;OmsOrderReturnReason&gt;&gt; list(@RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;OmsOrderReturnReason&gt; reasonList = orderReturnReasonService.list(pageSize, pageNum); return CommonResult.success(CommonPage.restPage(reasonList));} 1234567@ApiOperation(&quot;获取单个退货原因详情信息&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;OmsOrderReturnReason&gt; getItem(@PathVariable Long id) { OmsOrderReturnReason reason = orderReturnReasonService.getItem(id); return CommonResult.success(reason);} Delete12345678910@ApiOperation(&quot;批量删除退货原因&quot;)@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = orderReturnReasonService.delete(ids); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 购物车管理表格12345678910111213141516171819202122232425create table oms_cart_item( id bigint not null auto_increment, product_id bigint comment '商品的id', product_sku_id bigint comment '商品sku的id', member_id bigint comment '会员id', quantity int comment '购买数量', price decimal(10,2) comment '添加到购物车的价格', sp1 varchar(200) comment '销售属性1', sp2 varchar(200) comment '销售属性2', sp3 varchar(200) comment '销售属性3', product_pic varchar(1000) comment '商品主图', product_name varchar(500) comment '商品名称', product_brand varchar(200) comment '商品品牌', product_sn varchar(200) comment '商品的条码', product_sub_title varchar(500) comment '商品副标题（卖点）', product_sku_code varchar(200) comment '商品sku条码', member_nickname varchar(500) comment '会员昵称', create_date datetime comment '创建时间', modify_date datetime comment '修改时间', delete_status int(1) default 0 comment '是否删除', product_category_id bigint comment '商品的分类', product_attr varchar(500) comment '商品销售属性:[{&quot;key&quot;:&quot;颜色&quot;,&quot;value&quot;:&quot;银色&quot;},{&quot;key&quot;:&quot;容量&quot;,&quot;value&quot;:&quot;4G&quot;}]', primary key (id)); 流程图 前台 业务购物车ControllerCreate / Update 添加商品12345678910@ApiOperation(&quot;添加商品到购物车&quot;)@RequestMapping(value = &quot;/add&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult add(@RequestBody OmsCartItem cartItem) { int count = cartItemService.add(cartItem); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 如果商品不在购物车，新增商品；如果商品在购物车中，修改数量。 123456789101112131415161718@Overridepublic int add(OmsCartItem cartItem) { int count; UmsMember currentMember =memberService.getCurrentMember(); cartItem.setMemberId(currentMember.getId()); cartItem.setMemberNickname(currentMember.getNickname()); cartItem.setDeleteStatus(0); OmsCartItem existCartItem = getCartItem(cartItem); if (existCartItem == null) { cartItem.setCreateDate(new Date()); count = cartItemMapper.insert(cartItem); } else { cartItem.setModifyDate(new Date()); existCartItem.setQuantity(existCartItem.getQuantity() + cartItem.getQuantity()); count = cartItemMapper.updateByPrimaryKey(existCartItem); } return count;} 联表查询，要求用户Id + 商品Id + status -&gt; 获得购物车对应商品或空指针。 12345678910111213private OmsCartItem getCartItem(OmsCartItem cartItem) { OmsCartItemExample example = new OmsCartItemExample(); OmsCartItemExample.Criteria criteria = example.createCriteria().andMemberIdEqualTo(cartItem.getMemberId()) .andProductIdEqualTo(cartItem.getProductId()).andDeleteStatusEqualTo(0); if (cartItem.getProductSkuId()!=null) { criteria.andProductSkuIdEqualTo(cartItem.getProductSkuId()); } List&lt;OmsCartItem&gt; cartItemList = cartItemMapper.selectByExample(example); if (!CollectionUtils.isEmpty(cartItemList)) { return cartItemList.get(0); } return null;} Update 修改购物车商品数量1234567891011@ApiOperation(&quot;修改购物车中指定商品的数量&quot;)@RequestMapping(value = &quot;/update/quantity&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult updateQuantity(@RequestParam Long id, @RequestParam Integer quantity) { int count = cartItemService.updateQuantity(id, memberService.getCurrentMember().getId(), quantity); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Read 查询购物车11234567@ApiOperation(&quot;获取当前会员的购物车列表&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;OmsCartItem&gt;&gt; list() { List&lt;OmsCartItem&gt; cartItemList = cartItemService.list(memberService.getCurrentMember().getId()); return CommonResult.success(cartItemList);} Read 查询购物车21234567@ApiOperation(&quot;获取当前会员的购物车列表,包括促销信息&quot;)@RequestMapping(value = &quot;/list/promotion&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;CartPromotionItem&gt;&gt; listPromotion(@RequestParam(required = false) List&lt;Long&gt; cartIds) { List&lt;CartPromotionItem&gt; cartPromotionItemList = cartItemService.listPromotion(memberService.getCurrentMember().getId(), cartIds); return CommonResult.success(cartPromotionItemList);} 可以选择查询指定商品的优惠信息。 123456789101112@Overridepublic List&lt;CartPromotionItem&gt; listPromotion(Long memberId, List&lt;Long&gt; cartIds) { List&lt;OmsCartItem&gt; cartItemList = list(memberId); if(CollUtil.isNotEmpty(cartIds)){ cartItemList = cartItemList.stream().filter(item-&gt;cartIds.contains(item.getId())).collect(Collectors.toList()); } List&lt;CartPromotionItem&gt; cartPromotionItemList = new ArrayList&lt;&gt;(); if(!CollectionUtils.isEmpty(cartItemList)){ cartPromotionItemList = promotionService.calcCartPromotion(cartItemList); } return cartPromotionItemList;} 计算优惠的方法 calCartPromotion 比较复杂，这里用图来解析。 Read 获取商品规格 -&gt; 修改1234567@ApiOperation(&quot;获取购物车中指定商品的规格,用于重选规格&quot;)@RequestMapping(value = &quot;/getProduct/{productId}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CartProduct&gt; getCartProduct(@PathVariable Long productId) { CartProduct cartProduct = cartItemService.getCartProduct(productId); return CommonResult.success(cartProduct);} 12345678910@ApiOperation(&quot;修改购物车中商品的规格&quot;)@RequestMapping(value = &quot;/update/attr&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateAttr(@RequestBody OmsCartItem cartItem) { int count = cartItemService.updateAttr(cartItem); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Delete 删除商品12345678910@ApiOperation(&quot;删除购物车中的指定商品&quot;)@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = cartItemService.delete(memberService.getCurrentMember().getId(), ids); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} Delete 清空购物车12345678910@ApiOperation(&quot;清空当前会员的购物车&quot;)@RequestMapping(value = &quot;/clear&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult clear() { int count = cartItemService.clear(memberService.getCurrentMember().getId()); if (count &gt; 0) { return CommonResult.success(count); } return CommonResult.failed();} 订单 ControllerCreate 确认单生成购物车下单 -&gt; 选择收货地址/查看总金额/…。 1234567@ApiOperation(&quot;根据购物车信息生成确认单&quot;)@RequestMapping(value = &quot;/generateConfirmOrder&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult&lt;ConfirmOrderResult&gt; generateConfirmOrder(@RequestBody List&lt;Long&gt; cartIds) { ConfirmOrderResult confirmOrderResult = portalOrderService.generateConfirmOrder(cartIds); return CommonResult.success(confirmOrderResult);} 确认单需要确认的信息列表。 123456789101112131415161718192021222324252627public class ConfirmOrderResult { @ApiModelProperty(&quot;包含优惠信息的购物车信息&quot;) private List&lt;CartPromotionItem&gt; cartPromotionItemList; @ApiModelProperty(&quot;用户收货地址列表&quot;) private List&lt;UmsMemberReceiveAddress&gt; memberReceiveAddressList; @ApiModelProperty(&quot;用户可用优惠券列表&quot;) private List&lt;SmsCouponHistoryDetail&gt; couponHistoryDetailList; @ApiModelProperty(&quot;积分使用规则&quot;) private UmsIntegrationConsumeSetting integrationConsumeSetting; @ApiModelProperty(&quot;会员持有的积分&quot;) private Integer memberIntegration; @ApiModelProperty(&quot;计算的金额&quot;) private CalcAmount calcAmount; @Getter @Setter public static class CalcAmount{ @ApiModelProperty(&quot;订单商品总金额&quot;) private BigDecimal totalAmount; @ApiModelProperty(&quot;运费&quot;) private BigDecimal freightAmount; @ApiModelProperty(&quot;活动优惠&quot;) private BigDecimal promotionAmount; @ApiModelProperty(&quot;应付金额&quot;) private BigDecimal payAmount; }} Create 生成订单生成订单时，检查一些需要使用/扣除的东西（商品库存、优惠券、积分） （在实际应用中，下确认单时就已经锁定了库存，扣除了优惠券和积分，生成待支付订单） 1234567@ApiOperation(&quot;根据购物车信息生成订单&quot;)@RequestMapping(value = &quot;/generateOrder&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult generateOrder(@RequestBody OrderParam orderParam) { Map&lt;String, Object&gt; result = portalOrderService.generateOrder(orderParam); return CommonResult.success(result, &quot;下单成功&quot;);} 支付成功1234567@ApiOperation(&quot;用户支付成功的回调&quot;)@RequestMapping(value = &quot;/paySuccess&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult paySuccess(@RequestParam Long orderId,@RequestParam Integer payType) { Integer count = portalOrderService.paySuccess(orderId,payType); return CommonResult.success(count, &quot;支付成功&quot;);} 取消超时订单1234567@ApiOperation(&quot;自动取消超时订单&quot;)@RequestMapping(value = &quot;/cancelTimeOutOrder&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult cancelTimeOutOrder() { portalOrderService.cancelTimeOutOrder(); return CommonResult.success(null);}","link":"/2023/05/13/Mall-%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"},{"title":"Mall 商品模块分析","text":"商品模块数据库表解析（一） | mall学习教程 (macrozheng.com) 商品模块数据库表解析（二） | mall学习教程 (macrozheng.com) 商品管理模块分析数据表及其对应方法，CURD。 数据库表总览18 张表格，依赖关系复杂。 2. 添加商品表格商品总表pms_product 由基本信息，促销信息，属性/参数，关联组成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546create table pms_product( id bigint not null auto_increment, brand_id bigint comment '品牌id', product_category_id bigint comment '品牌分类id', feight_template_id bigint comment '运费模版id', product_attribute_category_id bigint comment '品牌属性分类id', name varchar(64) not null comment '商品名称', pic varchar(255) comment '图片', product_sn varchar(64) not null comment '货号', delete_status int(1) comment '删除状态：0-&gt;未删除；1-&gt;已删除', publish_status int(1) comment '上架状态：0-&gt;下架；1-&gt;上架', new_status int(1) comment '新品状态:0-&gt;不是新品；1-&gt;新品', recommand_status int(1) comment '推荐状态；0-&gt;不推荐；1-&gt;推荐', verify_status int(1) comment '审核状态：0-&gt;未审核；1-&gt;审核通过', sort int comment '排序', sale int comment '销量', price decimal(10,2) comment '价格', promotion_price decimal(10,2) comment '促销价格', gift_growth int default 0 comment '赠送的成长值', gift_point int default 0 comment '赠送的积分', use_point_limit int comment '限制使用的积分数', sub_title varchar(255) comment '副标题', description text comment '商品描述', original_price decimal(10,2) comment '市场价', stock int comment '库存', low_stock int comment '库存预警值', unit varchar(16) comment '单位', weight decimal(10,2) comment '商品重量，默认为克', preview_status int(1) comment '是否为预告商品：0-&gt;不是；1-&gt;是', service_ids varchar(64) comment '以逗号分割的产品服务：1-&gt;无忧退货；2-&gt;快速退款；3-&gt;免费包邮', keywords varchar(255) comment '关键字', note varchar(255) comment '备注', album_pics varchar(255) comment '画册图片，连产品图片限制为5张，以逗号分割', detail_title varchar(255) comment '详情标题', detail_desc text comment '详情描述', detail_html text comment '产品详情网页内容', detail_mobile_html text comment '移动端网页详情', promotion_start_time datetime comment '促销开始时间', promotion_end_time datetime comment '促销结束时间', promotion_per_limit int comment '活动限购数量', promotion_type int(1) comment '促销类型：0-&gt;没有促销使用原价;1-&gt;使用促销价；2-&gt;使用会员价；3-&gt;使用阶梯价格；4-&gt;使用满减价格；5-&gt;限时购', product_category_name varchar(255) comment '产品分类名称', brand_name varchar(255) comment '品牌名称', primary key (id)); SKU表库存单位表 -&gt; 商品信息 1234567891011121314151617create table pms_sku_stock( id bigint not null auto_increment, product_id bigint comment '商品id', sku_code varchar(64) not null comment 'sku编码', price decimal(10,2) comment '价格', stock int default 0 comment '库存', low_stock int comment '预警库存', sp1 varchar(64) comment '规格属性1', sp2 varchar(64) comment '规格属性2', sp3 varchar(64) comment '规格属性3', pic varchar(255) comment '展示图片', sale int comment '销量', promotion_price decimal(10,2) comment '单品促销价格', lock_stock int default 0 comment '锁定库存', primary key (id)); 优惠表格 阶梯表123456789create table pms_product_ladder( id bigint not null auto_increment, product_id bigint comment '商品id', count int comment '满足的商品数量', discount decimal(10,2) comment '折扣', price decimal(10,2) comment '折后价格', primary key (id)); 优惠表格 满减表12345678create table pms_product_full_reduction( id bigint not null auto_increment, product_id bigint comment '商品id', full_price decimal(10,2) comment '商品满足金额', reduce_price decimal(10,2) comment '商品减少金额', primary key (id)); 优惠表格 会员表123456789create table pms_member_price( id bigint not null auto_increment, product_id bigint comment '商品id', member_level_id bigint comment '会员等级id', member_price decimal(10,2) comment '会员价格', member_level_name varchar(100) comment '会员等级名称', primary key (id)); 后台总表 批量操作 添加商品信息 促销 商品属性 关联。 实现PmsProductControllerCreate 创建商品1234567891011@ApiOperation(&quot;创建商品&quot;)@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@RequestBody PmsProductParam productParam) { int count = productService.create(productParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 将前端传回的表单值封装到 productParam中，分门别类进行保存。 12345678910111213141516public class PmsProductParam extends PmsProduct{ @ApiModelProperty(&quot;商品阶梯价格设置&quot;) private List&lt;PmsProductLadder&gt; productLadderList; @ApiModelProperty(&quot;商品满减价格设置&quot;) private List&lt;PmsProductFullReduction&gt; productFullReductionList; @ApiModelProperty(&quot;商品会员价格设置&quot;) private List&lt;PmsMemberPrice&gt; memberPriceList; @ApiModelProperty(&quot;商品的sku库存信息&quot;) private List&lt;PmsSkuStock&gt; skuStockList; @ApiModelProperty(&quot;商品参数及自定义规格属性&quot;) private List&lt;PmsProductAttributeValue&gt; productAttributeValueList; @ApiModelProperty(&quot;专题和商品关系&quot;) private List&lt;CmsSubjectProductRelation&gt; subjectProductRelationList; @ApiModelProperty(&quot;优选专区和商品的关系&quot;) private List&lt;CmsPrefrenceAreaProductRelation&gt; prefrenceAreaProductRelationList;} 除了表单中提到的 阶梯表、满减表、会员价表、SKU 表。 有用于连接商品和商品属性的 productAttributeValueList，这个属性在商品分类模块可以设置。 12345678910111213public class PmsProductAttributeValue implements Serializable { private Long id; private Long productId; private Long productAttributeId; @ApiModelProperty(value = &quot;手动添加规格或参数的值，参数单值，规格有多个时以逗号隔开&quot;) private String value; ...} CmsSubjectProductRelation 和 CmsPrefrenceAreaProductRelation 也是连接用，不再赘述。 （居然使用 int count = 1 来作为返回值…） 12345678910111213141516171819202122232425262728@Overridepublic int create(PmsProductParam productParam) { int count; //创建商品 PmsProduct product = productParam; product.setId(null); productMapper.insertSelective(product); //根据促销类型设置价格：会员价格、阶梯价格、满减价格 Long productId = product.getId(); //会员价格 relateAndInsertList(memberPriceDao, productParam.getMemberPriceList(), productId); //阶梯价格 relateAndInsertList(productLadderDao, productParam.getProductLadderList(), productId); //满减价格 relateAndInsertList(productFullReductionDao, productParam.getProductFullReductionList(), productId); //处理sku的编码 handleSkuStockCode(productParam.getSkuStockList(),productId); //添加sku库存信息 relateAndInsertList(skuStockDao, productParam.getSkuStockList(), productId); //添加商品参数,添加自定义商品规格 relateAndInsertList(productAttributeValueDao, productParam.getProductAttributeValueList(), productId); //关联专题 relateAndInsertList(subjectProductRelationDao, productParam.getSubjectProductRelationList(), productId); //关联优选 relateAndInsertList(prefrenceAreaProductRelationDao, productParam.getPrefrenceAreaProductRelationList(), productId); count = 1; return count;} 代码复用 relateAndInsertList。 12345678910111213141516private void relateAndInsertList(Object dao, List dataList, Long productId) { try { if (CollectionUtils.isEmpty(dataList)) return; for (Object item : dataList) { Method setId = item.getClass().getMethod(&quot;setId&quot;, Long.class); setId.invoke(item, (Long) null); Method setProductId = item.getClass().getMethod(&quot;setProductId&quot;, Long.class); setProductId.invoke(item, productId); } Method insertList = dao.getClass().getMethod(&quot;insertList&quot;, List.class); insertList.invoke(dao, dataList); } catch (Exception e) { LOGGER.warn(&quot;创建产品出错:{}&quot;, e.getMessage()); throw new RuntimeException(e.getMessage()); }} Update 更新商品信息1234567891011@ApiOperation(&quot;更新商品&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @RequestBody PmsProductParam productParam) { int count = productService.update(id, productParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 12345678910111213@ApiOperation(&quot;批量修改审核状态&quot;)@RequestMapping(value = &quot;/update/verifyStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateVerifyStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;verifyStatus&quot;) Integer verifyStatus, @RequestParam(&quot;detail&quot;) String detail) { int count = productService.updateVerifyStatus(ids, verifyStatus, detail); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 123456789101112@ApiOperation(&quot;批量上下架商品&quot;)@RequestMapping(value = &quot;/update/publishStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updatePublishStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;publishStatus&quot;) Integer publishStatus) { int count = productService.updatePublishStatus(ids, publishStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 123456789101112@ApiOperation(&quot;批量推荐商品&quot;)@RequestMapping(value = &quot;/update/recommendStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateRecommendStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;recommendStatus&quot;) Integer recommendStatus) { int count = productService.updateRecommendStatus(ids, recommendStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 123456789101112@ApiOperation(&quot;批量设为新品&quot;)@RequestMapping(value = &quot;/update/newStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateNewStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;newStatus&quot;) Integer newStatus) { int count = productService.updateNewStatus(ids, newStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 123456789101112@ApiOperation(&quot;批量修改删除状态&quot;)@RequestMapping(value = &quot;/update/deleteStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateDeleteStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;deleteStatus&quot;) Integer deleteStatus) { int count = productService.updateDeleteStatus(ids, deleteStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} Read 查询商品信息（这里居然用 getUpdateInfo） 1234567@ApiOperation(&quot;根据商品id获取商品编辑信息&quot;)@RequestMapping(value = &quot;/updateInfo/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;PmsProductResult&gt; getUpdateInfo(@PathVariable Long id) { PmsProductResult productResult = productService.getUpdateInfo(id); return CommonResult.success(productResult);} 123456789@ApiOperation(&quot;查询商品&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;PmsProduct&gt;&gt; getList(PmsProductQueryParam productQueryParam, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;PmsProduct&gt; productList = productService.list(productQueryParam, pageSize, pageNum); return CommonResult.success(CommonPage.restPage(productList));} 1234567@ApiOperation(&quot;根据商品名称或货号模糊查询&quot;)@RequestMapping(value = &quot;/simpleList&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;PmsProduct&gt;&gt; getList(String keyword) { List&lt;PmsProduct&gt; productList = productService.list(keyword); return CommonResult.success(productList);} Delete ?甚至没有删除商品的功能。 3. 商品分类 商品分类表12345678910111213141516create table pms_product_category( id bigint not null auto_increment, parent_id bigint comment '上级分类的编号：0表示一级分类', name varchar(64) comment '名称', level int(1) comment '分类级别：0-&gt;1级；1-&gt;2级', product_count int comment '商品数量', product_unit varchar(64) comment '商品单位', nav_status int(1) comment '是否显示在导航栏：0-&gt;不显示；1-&gt;显示', show_status int(1) comment '显示状态：0-&gt;不显示；1-&gt;显示', sort int comment '排序', icon varchar(255) comment '图标', keywords varchar(255) comment '关键字', description text comment '描述', primary key (id)); 后台分类列表 添加/编辑分类 业务实现PmsProductCategoryControllerCreate 添加商品分类传入商品的分类信息 PmsProductCategoryParam，调用 Service 中的 create 方法。 1234567891011@ApiOperation(&quot;添加商品分类&quot;)@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@Validated @RequestBody PmsProductCategoryParam productCategoryParam) { int count = productCategoryService.create(productCategoryParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 123456789101112131415161718@Overridepublic int create(PmsProductCategoryParam pmsProductCategoryParam) { PmsProductCategory productCategory = new PmsProductCategory(); productCategory.setProductCount(0); BeanUtils.copyProperties(pmsProductCategoryParam, productCategory); // 没有父分类时为一级分类 setCategoryLevel(productCategory); int count = productCategoryMapper.insertSelective(productCategory); // 创建筛选属性关联 List&lt;Long&gt; productAttributeIdList = pmsProductCategoryParam.getProductAttributeIdList(); // 属性筛选并没有与商品分类绑定，而是另外创建对象？ if(!CollectionUtils.isEmpty(productAttributeIdList)){ insertRelationList(productCategory.getId(), productAttributeIdList); } return count;} 12345678910private void insertRelationList(Long productCategoryId, List&lt;Long&gt; productAttributeIdList) { List&lt;PmsProductCategoryAttributeRelation&gt; relationList = new ArrayList&lt;&gt;(); for (Long productAttrId : productAttributeIdList) { PmsProductCategoryAttributeRelation relation = new PmsProductCategoryAttributeRelation(); relation.setProductAttributeId(productAttrId); relation.setProductCategoryId(productCategoryId); relationList.add(relation); } productCategoryAttributeRelationDao.insertList(relationList);} Update 更新商品分类12345678910111213@ApiOperation(&quot;修改商品分类&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @Validated @RequestBody PmsProductCategoryParam productCategoryParam) { int count = productCategoryService.update(id, productCategoryParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 12345678910111213141516171819202122232425262728@Overridepublic int update(Long id, PmsProductCategoryParam pmsProductCategoryParam) { PmsProductCategory productCategory = new PmsProductCategory(); productCategory.setId(id); BeanUtils.copyProperties(pmsProductCategoryParam, productCategory); setCategoryLevel(productCategory); //更新商品分类时要更新商品中的名称 PmsProduct product = new PmsProduct(); product.setProductCategoryName(productCategory.getName()); PmsProductExample example = new PmsProductExample(); example.createCriteria().andProductCategoryIdEqualTo(id); productMapper.updateByExampleSelective(product,example); //同时更新筛选属性的信息 if(!CollectionUtils.isEmpty(pmsProductCategoryParam.getProductAttributeIdList())){ PmsProductCategoryAttributeRelationExample relationExample = new PmsProductCategoryAttributeRelationExample(); relationExample.createCriteria().andProductCategoryIdEqualTo(id); productCategoryAttributeRelationMapper.deleteByExample(relationExample); insertRelationList(id,pmsProductCategoryParam.getProductAttributeIdList()); } else { PmsProductCategoryAttributeRelationExample relationExample = new PmsProductCategoryAttributeRelationExample(); relationExample.createCriteria().andProductCategoryIdEqualTo(id); productCategoryAttributeRelationMapper.deleteByExample(relationExample); } return productCategoryMapper.updateByPrimaryKeySelective(productCategory);} Update 更新显示信息11234567891011@ApiOperation(&quot;修改导航栏显示状态&quot;)@RequestMapping(value = &quot;/update/navStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateNavStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;navStatus&quot;) Integer navStatus) { int count = productCategoryService.updateNavStatus(ids, navStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); } } 12345678@Overridepublic int updateNavStatus(List&lt;Long&gt; ids, Integer navStatus) { PmsProductCategory productCategory = new PmsProductCategory(); productCategory.setNavStatus(navStatus); PmsProductCategoryExample example = new PmsProductCategoryExample(); example.createCriteria().andIdIn(ids); return productCategoryMapper.updateByExampleSelective(productCategory, example);} Update 更新显示信息21234567891011@ApiOperation(&quot;修改显示状态&quot;)@RequestMapping(value = &quot;/update/showStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateShowStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;showStatus&quot;) Integer showStatus) { int count = productCategoryService.updateShowStatus(ids, showStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 12345678@Overridepublic int updateShowStatus(List&lt;Long&gt; ids, Integer showStatus) { PmsProductCategory productCategory = new PmsProductCategory(); productCategory.setShowStatus(showStatus); PmsProductCategoryExample example = new PmsProductCategoryExample(); example.createCriteria().andIdIn(ids); return productCategoryMapper.updateByExampleSelective(productCategory, example);} Read 分页查询商品分类这里的 CommonResult&lt;CommonPage&lt;PmsProductCategory&gt;&gt; 两级封装 getList 返回 List&lt;PmsProductCategory&gt;，再将 List -&gt; Page 对象 123456789@ApiOperation(&quot;分页查询商品分类&quot;)@RequestMapping(value = &quot;/list/{parentId}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;PmsProductCategory&gt;&gt; getList(@PathVariable Long parentId, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;PmsProductCategory&gt; productCategoryList = productCategoryService.getList(parentId, pageSize, pageNum); return CommonResult.success(CommonPage.restPage(productCategoryList));} 这里的 PageHelper 是如何生效的？ 这行代码实际上将分页信息保存到了线程中。 SpringBoot 则为 SqlSessionFactory 添加了 PageInterceptor 拦截器，在SQL执行前添加分页信息。 (43条消息) PageHelper 原理解析_lukamao的博客-CSDN博客 12345678@Overridepublic List&lt;PmsProductCategory&gt; getList(Long parentId, Integer pageSize, Integer pageNum) { PageHelper.startPage(pageNum, pageSize); PmsProductCategoryExample example = new PmsProductCategoryExample(); example.setOrderByClause(&quot;sort desc&quot;); example.createCriteria().andParentIdEqualTo(parentId); return productCategoryMapper.selectByExample(example);} 新增 CommonPage 来获取想要的信息。 （Page 类在 Mybatis_PageHelper 已经提供了，直接用 PageInfo 也没差） Mybatis 分类对象：http://git.oschina.net/free/Mybatis_PageHelper 12345678910public static &lt;T&gt; CommonPage&lt;T&gt; restPage(List&lt;T&gt; list) { PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;T&gt;(list); result.setTotalPage(pageInfo.getPages()); result.setPageNum(pageInfo.getPageNum()); result.setPageSize(pageInfo.getPageSize()); result.setTotal(pageInfo.getTotal()); result.setList(pageInfo.getList()); return result;} Read 根据ID查询商品分类1234567@ApiOperation(&quot;根据id获取商品分类&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;PmsProductCategory&gt; getItem(@PathVariable Long id) { PmsProductCategory productCategory = productCategoryService.getItem(id); return CommonResult.success(productCategory);} 1234@Overridepublic PmsProductCategory getItem(Long id) { return productCategoryMapper.selectByPrimaryKey(id);} Read 查询所有分类与子分类1234567@ApiOperation(&quot;查询所有一级分类及子分类&quot;)@RequestMapping(value = &quot;/list/withChildren&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;PmsProductCategoryWithChildrenItem&gt;&gt; listWithChildren() { List&lt;PmsProductCategoryWithChildrenItem&gt; list = productCategoryService.listWithChildren(); return CommonResult.success(list);} 这个方法 Mybatis Generator 没有提供，需要自定义。 1234@Overridepublic List&lt;PmsProductCategoryWithChildrenItem&gt; listWithChildren() { return productCategoryDao.listWithChildren();} 联表查询。 123456789&lt;select id=&quot;listWithChildren&quot; resultMap=&quot;listWithChildrenMap&quot;&gt; select c1.id, c1.name, c2.id child_id, c2.name child_name from pms_product_category c1 left join pms_product_category c2 on c1.id = c2.parent_id where c1.parent_id = 0&lt;/select&gt; Delete 根据ID删除商品分类1234567891011@ApiOperation(&quot;删除商品分类&quot;)@RequestMapping(value = &quot;/delete/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@PathVariable Long id) { int count = productCategoryService.delete(id); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 1234@Overridepublic int delete(Long id) { return productCategoryMapper.deleteByPrimaryKey(id);} 4. 商品规格/参数表格总表对应后台的第一张图。 12345678create table pms_product_attribute_category( id bigint not null auto_increment, name varchar(64) comment '名称', attribute_count int comment '属性数量', param_count int comment '参数数量', primary key (id)); 属性/参数表存入的属性和参数都用这张表来存储，只用 type 字段进行区分。 12345678910111213141516create table pms_product_attribute( id bigint not null auto_increment, product_attribute_category_id bigint comment '商品属性分类id', name varchar(64) comment '名称', select_type int(1) comment '属性选择类型：0-&gt;唯一；1-&gt;单选；2-&gt;多选；对应属性和参数意义不同；', input_type int(1) comment '属性录入方式：0-&gt;手工录入；1-&gt;从列表中选取', input_list varchar(255) comment '可选值列表，以逗号隔开', sort int comment '排序字段：最高的可以单独上传图片', filter_type int(1) comment '分类筛选样式：1-&gt;普通；1-&gt;颜色', search_type int(1) comment '检索类型；0-&gt;不需要进行检索；1-&gt;关键字检索；2-&gt;范围检索', related_status int(1) comment '相同属性产品是否关联；0-&gt;不关联；1-&gt;关联', hand_add_status int(1) comment '是否支持手动新增；0-&gt;不支持；1-&gt;支持', type int(1) comment '属性的类型；0-&gt;规格；1-&gt;参数', primary key (id)); 添加属性/参数手动填入的参数用这张表存储。 12345678create table pms_product_attribute_value( id bigint not null auto_increment, product_id bigint comment '商品id', product_attribute_id bigint comment '商品属性id', value varchar(64) comment '手动添加规格或参数的值，参数单值，规格有多个时以逗号隔开', primary key (id)); 分类 -&gt; 属性/参数筛选分类后获得对应商品的属性/参数 1234567create table pms_product_category_attribute_relation( id bigint not null auto_increment, product_category_id bigint comment '商品分类id', product_attribute_id bigint comment '商品属性id', primary key (id)); 后台 添加新的类型（这个属性应该和商品分类表绑定，这里处理？） 属性列表 -&gt; 选购商品时的选择（选择衣服的颜色和尺码，手机的存储大小等）。 参数列表 -&gt; 商品的详细信息（衣服的材质、手机的尺寸等） 添加属性/参数表 业务实现PmsProductAttributeCategoryController对应总表。 Create 创建新的类型12345678910@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@RequestParam String name) { int count = productAttributeCategoryService.create(name); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} Update 修改类型名12345678910@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @RequestParam String name) { int count = productAttributeCategoryService.update(id, name); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} Read 读取类型的属性/参数1234567@ApiOperation(&quot;获取单个商品属性分类信息&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;PmsProductAttributeCategory&gt; getItem(@PathVariable Long id) { PmsProductAttributeCategory productAttributeCategory = productAttributeCategoryService.getItem(id); return CommonResult.success(productAttributeCategory);} 1234567@ApiOperation(&quot;分页获取所有商品属性分类&quot;)@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;PmsProductAttributeCategory&gt;&gt; getList(@RequestParam(defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;PmsProductAttributeCategory&gt; productAttributeCategoryList = productAttributeCategoryService.getList(pageSize, pageNum); return CommonResult.success(CommonPage.restPage(productAttributeCategoryList));} 1234567@ApiOperation(&quot;获取所有商品属性分类及其下属性&quot;)@RequestMapping(value = &quot;/list/withAttr&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;PmsProductAttributeCategoryItem&gt;&gt; getListWithAttr() { List&lt;PmsProductAttributeCategoryItem&gt; productAttributeCategoryResultList = productAttributeCategoryService.getListWithAttr(); return CommonResult.success(productAttributeCategoryResultList);} Delete 删除类型1234567891011@ApiOperation(&quot;删除单个商品属性分类&quot;)@RequestMapping(value = &quot;/delete/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult delete(@PathVariable Long id) { int count = productAttributeCategoryService.delete(id); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} PmsProductAttributeController对应属性/参数表 Create 写入类型属性/参数1234567891011@ApiOperation(&quot;添加商品属性信息&quot;)@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@RequestBody PmsProductAttributeParam productAttributeParam) { int count = productAttributeService.create(productAttributeParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} Update 修改类型属性/参数1234567891011@ApiOperation(&quot;修改商品属性信息&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable Long id, @RequestBody PmsProductAttributeParam productAttributeParam) { int count = productAttributeService.update(id, productAttributeParam); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} Read 查询类型属性/参数1234567891011@ApiOperation(&quot;根据分类查询属性列表或参数列表&quot;)@ApiImplicitParams({@ApiImplicitParam(name = &quot;type&quot;, value = &quot;0表示属性，1表示参数&quot;, required = true, paramType = &quot;query&quot;, dataType = &quot;integer&quot;)})@RequestMapping(value = &quot;/list/{cid}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;CommonPage&lt;PmsProductAttribute&gt;&gt; getList(@PathVariable Long cid, @RequestParam(value = &quot;type&quot;) Integer type, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) { List&lt;PmsProductAttribute&gt; productAttributeList = productAttributeService.getList(cid, type, pageSize, pageNum); return CommonResult.success(CommonPage.restPage(productAttributeList));} 1234567@ApiOperation(&quot;查询单个商品属性&quot;)@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;PmsProductAttribute&gt; getItem(@PathVariable Long id) { PmsProductAttribute productAttribute = productAttributeService.getItem(id); return CommonResult.success(productAttribute);} 1234567@ApiOperation(&quot;根据商品分类的id获取商品属性及属性分类&quot;)@RequestMapping(value = &quot;/attrInfo/{productCategoryId}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;ProductAttrInfo&gt;&gt; getAttrInfo(@PathVariable Long productCategoryId) { List&lt;ProductAttrInfo&gt; productAttrInfoList = productAttributeService.getProductAttrInfo(productCategoryId); return CommonResult.success(productAttrInfoList);} Delete 删除属性/参数1234567891011@ApiOperation(&quot;批量删除商品属性&quot;)@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = productAttributeService.delete(ids); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 5. 品牌管理商品品牌表123456789101112131415create table pms_brand( id bigint not null auto_increment, name varchar(64) comment '名称', first_letter varchar(8) comment '首字母', sort int comment '排序', factory_status int(1) comment '是否为品牌制造商：0-&gt;不是；1-&gt;是', show_status int(1) comment '是否显示', product_count int comment '产品数量', product_comment_count int comment '产品评论数量', logo varchar(255) comment '品牌logo', big_pic varchar(255) comment '专区大图', brand_story text comment '品牌故事', primary key (id)); 后台品牌列表 添加/编辑品牌 业务实现PmsBrandControllerCreate 创建品牌12345678910111213@ApiOperation(value = &quot;添加品牌&quot;)@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult create(@Validated @RequestBody PmsBrandParam pmsBrand) { CommonResult commonResult; int count = brandService.createBrand(pmsBrand); if (count == 1) { commonResult = CommonResult.success(count); } else { commonResult = CommonResult.failed(); } return commonResult;} 12345678910@Overridepublic int createBrand(PmsBrandParam pmsBrandParam) { PmsBrand pmsBrand = new PmsBrand(); BeanUtils.copyProperties(pmsBrandParam, pmsBrand); //如果创建时首字母为空，取名称的第一个为首字母 if (StrUtil.isEmpty(pmsBrand.getFirstLetter())) { pmsBrand.setFirstLetter(pmsBrand.getName().substring(0, 1)); } return brandMapper.insertSelective(pmsBrand);} Update 更新品牌1234567891011121314@ApiOperation(value = &quot;更新品牌&quot;)@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult update(@PathVariable(&quot;id&quot;) Long id, @Validated @RequestBody PmsBrandParam pmsBrandParam) { CommonResult commonResult; int count = brandService.updateBrand(id, pmsBrandParam); if (count == 1) { commonResult = CommonResult.success(count); } else { commonResult = CommonResult.failed(); } return commonResult;} 123456789101112131415161718@Overridepublic int updateBrand(Long id, PmsBrandParam pmsBrandParam) { PmsBrand pmsBrand = new PmsBrand(); BeanUtils.copyProperties(pmsBrandParam, pmsBrand); pmsBrand.setId(id); //如果创建时首字母为空，取名称的第一个为首字母 if (StrUtil.isEmpty(pmsBrand.getFirstLetter())) { pmsBrand.setFirstLetter(pmsBrand.getName().substring(0, 1)); } //更新品牌时要更新商品中的品牌名称 PmsProduct product = new PmsProduct(); product.setBrandName(pmsBrand.getName()); PmsProductExample example = new PmsProductExample(); example.createCriteria().andBrandIdEqualTo(id); productMapper.updateByExampleSelective(product,example); return brandMapper.updateByPrimaryKeySelective(pmsBrand);} Update 更新显示信息123456789101112@ApiOperation(value = &quot;批量更新显示状态&quot;)@RequestMapping(value = &quot;/update/showStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateShowStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;showStatus&quot;) Integer showStatus) { int count = brandService.updateShowStatus(ids, showStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 12345678@Overridepublic int updateShowStatus(List&lt;Long&gt; ids, Integer showStatus) { PmsBrand pmsBrand = new PmsBrand(); pmsBrand.setShowStatus(showStatus); PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.createCriteria().andIdIn(ids); return brandMapper.updateByExampleSelective(pmsBrand, pmsBrandExample);} Update 更新品牌商信息123456789101112@ApiOperation(value = &quot;批量更新厂家制造商状态&quot;)@RequestMapping(value = &quot;/update/factoryStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic CommonResult updateFactoryStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;factoryStatus&quot;) Integer factoryStatus) { int count = brandService.updateFactoryStatus(ids, factoryStatus); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); }} 12345678@Overridepublic int updateFactoryStatus(List&lt;Long&gt; ids, Integer factoryStatus) { PmsBrand pmsBrand = new PmsBrand(); pmsBrand.setFactoryStatus(factoryStatus); PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.createCriteria().andIdIn(ids); return brandMapper.updateByExampleSelective(pmsBrand, pmsBrandExample);} Read 读取所有品牌123456@ApiOperation(value = &quot;获取全部品牌列表&quot;)@RequestMapping(value = &quot;/listAll&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult&lt;List&lt;PmsBrand&gt;&gt; getList() { return CommonResult.success(brandService.listAllBrand());} 1234@Overridepublic List&lt;PmsBrand&gt; listAllBrand() { return brandMapper.selectByExample(new PmsBrandExample());} Delete 删除品牌1234567891011121314151617181920212223@ApiOperation(value = &quot;删除品牌&quot;)@RequestMapping(value = &quot;/delete/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic CommonResult delete(@PathVariable(&quot;id&quot;) Long id) { int count = brandService.deleteBrand(id); if (count == 1) { return CommonResult.success(null); } else { return CommonResult.failed(); }}@ApiOperation(value = &quot;批量删除品牌&quot;) @RequestMapping(value = &quot;/delete/batch&quot;, method = RequestMethod.POST) @ResponseBody public CommonResult deleteBatch(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { int count = brandService.deleteBrand(ids); if (count &gt; 0) { return CommonResult.success(count); } else { return CommonResult.failed(); } } 1234567891011@Overridepublic int deleteBrand(Long id) { return brandMapper.deleteByPrimaryKey(id);}@Overridepublic int deleteBrand(List&lt;Long&gt; ids) { PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.createCriteria().andIdIn(ids); return brandMapper.deleteByExample(pmsBrandExample);}","link":"/2023/05/13/Mall-%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"},{"title":"README","text":"本博客作为备份。 Spring Boot 官方文档阅读：","link":"/2023/05/06/README/"},{"title":"MyMall","text":"从头搭建是否太过复杂…?mall整合SpringBoot+MyBatis搭建基本骨架 | mall学习教程 (macrozheng.com) SpringBoot + MyBatis 基本骨架搭建使用 IDEA 初始化 SpringBoot 项目，并引入依赖。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.11&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;8.0.32&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置数据库和 MyBatis 的 mapper.xml 路径12345678910111213server: port: 8080spring: datasource: url: jdbc:mysql://localhost:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: MySQL990703mybatis: mapper-locations: - classpath:mapper/*.xml - classpath*:com/**/mapper/*.xml 代码生成器配置内容参考：MyBatis Generator Core – MyBatis Generator XML Configuration File Reference Mybatis代码生成器——Mybatis-Generator使用详解_昨天今日未来的博客-CSDN博客 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;properties resource=&quot;generator.properties&quot;/&gt; &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 为模型生成序列化方法--&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt; &lt;!-- 为生成的Java模型创建一个toString方法 --&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt; &lt;!--可以自定义生成model的代码注释--&gt; &lt;commentGenerator type=&quot;com.macro.mall.tiny.mbg.CommentGenerator&quot;&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库连接--&gt; &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.connectionURL}&quot; userId=&quot;${jdbc.userId}&quot; password=&quot;${jdbc.password}&quot;&gt; &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt; &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt; &lt;/jdbcConnection&gt; &lt;!--指定生成model的路径--&gt; &lt;javaModelGenerator targetPackage=&quot;com.macro.mall.tiny.mbg.model&quot; targetProject=&quot;mall-tiny-01\\src\\main\\java&quot;/&gt; &lt;!--指定生成mapper.xml的路径--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.macro.mall.tiny.mbg.mapper&quot; targetProject=&quot;mall-tiny-01\\src\\main\\resources&quot;/&gt; &lt;!--指定生成mapper接口的的路径--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.macro.mall.tiny.mbg.mapper&quot; targetProject=&quot;mall-tiny-01\\src\\main\\java&quot;/&gt; &lt;!--生成全部表tableName设为%--&gt; &lt;table tableName=&quot;%&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 通用的代码生成模板： 1234567891011121314151617181920212223public class Generator { public static void main(String[] args) throws Exception { //MBG 执行过程中的警告信息 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); //当生成的代码重复时，覆盖原代码 boolean overwrite = true; //读取我们的 MBG 配置文件 InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(is); is.close(); DefaultShellCallback callback = new DefaultShellCallback(overwrite); //创建 MBG MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); //执行生成代码 myBatisGenerator.generate(null); //输出警告信息 for (String warning : warnings) { System.out.println(warning); } }} 对生成的 mapper 开启扫描。 此处将自定义 mapper 和生成 mapper 分开，而非合并处理。 12345@Configuration@MapperScan(&quot;com.moonlightqz.mymall.mbg.mapper&quot;)public class MyBatisConfig { } 实现 CURD 接口Controller：以 PmsBrandController 为例Create 新增 BrandController 创建 Brand 需要提交表单，改用 POST 1234567891011@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST) @ResponseBody public ResultVO createBrand(@Validated @RequestBody PmsBrandDto pmsBrandDto) { boolean flag = pmsBrandService.createBrand(pmsBrandDto); if(flag) { return ResultVO.successWithMsg(&quot;创建Brand成功&quot;); } else { return ResultVO.failedWithMsg(&quot;创建Brand失败&quot;); } } 创建一个用于传输 Brand 信息的 PmsBrandDto，同时填上验证信息，此处需要引入 validation 依赖。 需要常见的自定义注解 @FlagValidator，用于验证状态是否在指定范围。 public class PmsBrandDto { @NotEmpty private String name; private String firstLetter; @Min(value = 0) private Integer sort; @FlagValidator(value = {&quot;0&quot;,&quot;1&quot;}, message = &quot;厂家状态不正确&quot;) private Integer factoryStatus; @FlagValidator(value = {&quot;0&quot;,&quot;1&quot;}, message = &quot;显示状态不正确&quot;) private Integer showStatus; private String logo; private String bigPic; private String brandStory; // ... } Service，用到了工具包 Hutool 1234567891011@Overridepublic boolean createBrand(PmsBrandDto pmsBrandDto) { PmsBrand pmsBrand = new PmsBrand(); BeanUtils.copyProperties(pmsBrandDto, pmsBrand); // 自动填充，当创建Brand的首字母为空时，取名称的首字母 if (StrUtil.isEmpty(pmsBrand.getFirstLetter())) { pmsBrand.setFirstLetter(pmsBrand.getName().substring(0, 1)); } return pmsBrandMapper.insert(pmsBrand);} 使用 Postman 测试接口： Update 根据Id更新BrandController 123456789101112@RequestMapping(value = &quot;/update/{id}&quot;, method = RequestMethod.POST) @ResponseBody public ResultVO update(@PathVariable(&quot;id&quot;) Long id, @Validated @RequestBody PmsBrandDto pmsBrandDto) { boolean flag = pmsBrandService.updateBrand(id, pmsBrandDto); if (flag) { return ResultVO.successWithMsg(&quot;更新Brand成功&quot;); } else { return ResultVO.failedWithMsg(&quot;更新Brand失败&quot;); } } 使用 @Transactional 注解，当事务抛出异常时进行回滚。 12@Transactionalint updateBrand(Long id, PmsBrandDto pmsBrandDto); Service，updateByPrimaryKeySelective 有什么就更新什么。 1234567891011@Override public boolean updateBrand(Long id, PmsBrandDto pmsBrandDto) { PmsBrand pmsBrand = new PmsBrand(); pmsBrand.setId(id); BeanUtils.copyProperties(pmsBrandDto, pmsBrand); // 自动填充，当创建Brand的首字母为空时，取名称的首字母 if (StrUtil.isEmpty(pmsBrand.getFirstLetter())) { pmsBrand.setFirstLetter(pmsBrand.getName().substring(0, 1)); } return pmsBrandMapper.updateByPrimaryKeySelective(pmsBrand); } Update 根据Id批量更新显示状态Controller，使用 RequestParam 接收参数 RequestParam 和 RequestBody 区别详见： (43条消息) @RequestBody和@RequestParam区别全面详细_一斤白菜的博客-CSDN博客 1234567891011@RequestMapping(value = &quot;/update/showStatus&quot;, method = RequestMethod.POST)@ResponseBodypublic ResultVO updateShowStatus(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids, @RequestParam(&quot;showStatus&quot;) Integer showStatus) { boolean flag = pmsBrandService.updateShowStatus(ids, showStatus); if (flag) { return ResultVO.successWithMsg(&quot;更新显示状态成功&quot;); } else { return ResultVO.failedWithMsg(&quot;更新显示状态失败&quot;); }} Service，这里用到了 Criteria()，具体如何使用见： (43条消息) mybatis的example.createCriteria()方法学习记录_VVAIVG的博客-CSDN博客 12345678@Override public boolean updateShowStatus(List&lt;Long&gt; ids, Integer showStatus) { PmsBrand pmsBrand = new PmsBrand(); pmsBrand.setShowStatus(showStatus); PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.createCriteria().andIdIn(ids); return pmsBrandMapper.updateByExampleSelective(pmsBrand, pmsBrandExample); } Read 读取所有Brand12345678910@Autowiredprivate PmsBrandService pmsBrandService;private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);@RequestMapping(value = &quot;/listAll&quot;, method = RequestMethod.GET)@ResponseBodypublic ResultVO&lt;List&lt;PmsBrand&gt;&gt; getBrandList() { return ResultVO.successWithData(pmsBrandService.listAllBrand());} ResultVO 统一整个项目请求返回的结果，内容包括状态码，响应信息和数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ResultVO&lt;T&gt; { private Integer code; private String message; private T data; public ResultVO() { } public ResultVO(T data) { this(ResultCode.SUCCESS, data); } public ResultVO(ResultCode resultCode, T data) { this.code = resultCode.getCode(); this.message = resultCode.getMsg(); this.data = data; } public ResultVO(int code, String msg) { this.code = code; this.message = msg; } /** * 请求处理成功且不需要返回数据时使用的工具方法 * * @return */ public static &lt;Type&gt; ResultVO&lt;Type&gt; successWithoutData() { return successWithData(null); } /** * 请求处理成功且需要返回数据时使用的工具方法 * * @param data 要返回的数据 * @return */ public static &lt;Type&gt; ResultVO&lt;Type&gt; successWithData(Type data) { return new ResultVO&lt;Type&gt;(ResultCode.SUCCESS, data); } public static ResultVO successWithMsg(String message) { return new ResultVO(ResultCode.SUCCESS.getCode(), message); } public static ResultVO failedWithMsg(String message) { return new ResultVO(ResultCode.FAILED.getCode(), message); } /** * 请求处理失败后使用的工具方法 * * @return */ public static &lt;Type&gt; ResultVO&lt;Type&gt; failed() { return new ResultVO&lt;Type&gt;(ResultCode.FAILED, null); } /** * 请求处理失败后使用的工具方法 * * @param resultCode * @param &lt;Type&gt; * @return */ public static &lt;Type&gt; ResultVO&lt;Type&gt; failed(ResultCode resultCode) { return new ResultVO&lt;Type&gt;(resultCode, null); } @Override public String toString() { return &quot;ResultVO{&quot; + &quot;code=&quot; + code + &quot;, msg='&quot; + message + '\\'' + &quot;, data=&quot; + data + '}'; }} 状态码的描述单独放在枚举类的 ResultCode 中。 12345678910111213141516public enum ResultCode { private Integer code; private String msg; SUCCESS(200, &quot;操作成功&quot;), FAILED(500, &quot;操作失败&quot;), VALIDATE_FAILED(501, &quot;参数校验失败&quot;), ERROR(502, &quot;未知错误&quot;), ERROR_LOGIN_NOT_EMPTY(510, &quot;账号或密码不能为空&quot;), ERROR_LOGIN_LOCK(511, &quot;密码输错次数过多,已被锁定30分钟&quot;); // standard getter } 回过头看 PmsBrandService 提供的 listAllBrand 方法，调用了 selectByExample； 1234@Override public List&lt;PmsBrand&gt; listAllBrand() { return pmsBrandMapper.selectByExample(new PmsBrandExample()); } 这里传入的 PmsBrandExample 作为 SQL 语句的参数。 123456789public class PmsBrandExample { protected String orderByClause; protected boolean distinct; protected List&lt;Criteria&gt; oredCriteria; // ... Mapper 对应的语法，distinct -&gt; 去重，orderByClause -&gt; 按照某字段排序，oredCriteria 链式查询。 1234567891011121314&lt;select id=&quot;selectByExample&quot; parameterType=&quot;com.moonlightqz.mymall.mapper.PmsBrandExample&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;if test=&quot;distinct&quot;&gt; distinct &lt;/if&gt; &lt;include refid=&quot;Base_Column_List&quot; /&gt; from pms_brand &lt;if test=&quot;_parameter != null&quot;&gt; &lt;include refid=&quot;Example_Where_Clause&quot; /&gt; &lt;/if&gt; &lt;if test=&quot;orderByClause != null&quot;&gt; order by ${orderByClause} &lt;/if&gt; &lt;/select&gt; 调整项目结构后运行，访问 localhost:8080/brand/listAll 成功。 Read 根据 Id 查询 BrandController 12345@RequestMapping(value = &quot;/list/{id}&quot;, method = RequestMethod.GET)@ResponseBodypublic ResultVO&lt;PmsBrand&gt; getBrandById(@PathVariable Long id) { return ResultVO.successWithData(pmsBrandService.getBrandById(id));} Service 1234@Overridepublic PmsBrand getBrand(Long id) { return pmsBrandMapper.selectByPrimaryKey(id);} 分页查询 Brand用到 PageHelper，待分析 123456789@RequestMapping(value = &quot;/listPage&quot;, method = RequestMethod.GET) @ResponseBody public ResultVO&lt;PageDto&lt;PmsBrand&gt;&gt; getList(@RequestParam(value = &quot;keyword&quot;, required = false) String keyword, @RequestParam(value = &quot;showStatus&quot;,required = false) Integer showStatus, @RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize) { List&lt;PmsBrand&gt; brandList = pmsBrandService.listBrand(keyword,showStatus,pageNum, pageSize); return ResultVO.successWithData(PageDto.restPage(brandList)); } Service 12345678910111213public List&lt;PmsBrand&gt; listBrand(String keyword, Integer showStatus, int pageNum, int pageSize) { PageHelper.startPage(pageNum, pageSize); PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.setOrderByClause(&quot;sort desc&quot;); PmsBrandExample.Criteria criteria = pmsBrandExample.createCriteria(); if (!StrUtil.isEmpty(keyword)) { criteria.andNameLike(&quot;%&quot; + keyword + &quot;%&quot;); } if(showStatus!=null){ criteria.andShowStatusEqualTo(showStatus); } return pmsBrandMapper.selectByExample(pmsBrandExample);} Delete 根据Id删除BrandController 1234567891011@RequestMapping(value = &quot;/delete/{id}&quot;, method = RequestMethod.GET) @ResponseBody public ResultVO delete(@PathVariable(&quot;id&quot;) Long id) { boolean flag = pmsBrandService.deleteBrand(id); if (flag) { return ResultVO.successWithMsg(&quot;删除Brand成功&quot;); } else { return ResultVO.failedWithMsg(&quot;删除Brand失败&quot;); } } Service 1234@Overridepublic boolean deleteBrand(Long id) { return pmsBrandMapper.deleteByPrimaryKey(id);} Delete 批量删除BrandController 12345678910@RequestMapping(value = &quot;/delete/batch&quot;, method = RequestMethod.POST) @ResponseBody public ResultVO deleteBatch(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) { boolean flag = pmsBrandService.deleteBrand(ids); if (flag) { return ResultVO.successWithMsg(&quot;批量删除Brand成功&quot;); } else { return ResultVO.failedWithMsg(&quot;批量删除Brand失败&quot;); } } Service 123456@Override public boolean deleteBrand(List&lt;Long&gt; ids) { PmsBrandExample pmsBrandExample = new PmsBrandExample(); pmsBrandExample.createCriteria().andIdIn(ids); return pmsBrandMapper.deleteByExample(pmsBrandExample); } 这样一来，我们完成了 PmsBrand 这张表的架构搭建。 还没完呢！ Swagger-UI 生成 API 文档引入依赖 Swagger2Config 标准配置 123456789101112131415161718192021222324252627282930313233343536@Configuration@EnableWebMvc@EnableSwagger2public class Swagger2Config implements WebMvcConfigurer { @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //为当前包下controller生成API文档 .apis(RequestHandlerSelectors.basePackage(&quot;com.moonlightqz.mymall.controller&quot;)) //为有@Api注解的Controller生成API文档// .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) //为有@ApiOperation注解的方法生成API文档// .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); registry.addResourceHandler(&quot;swagger-ui.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;SwaggerUI演示&quot;) .description(&quot;mymall&quot;) .contact(&quot;moonlightqz&quot;) .version(&quot;1.0&quot;) .build(); }} 回头给 Controller 的每个类上添加 @ApiOperation(value = “msg”) 实体类用到 @ApiModel 和 @ApiModelProperty，此略 访问 http://localhost:8080/swagger-ui.html Redis引入 Redis 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置 Redis 12345678910111213spring: redis: host: localhost # Redis服务器地址 database: 0 # Redis数据库索引（默认为0） port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） jedis: pool: max-active: 8 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 8 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 timeout: 3000ms # 连接超时时间（毫秒） 添加常用 RedisService 接口方法。 12345678910111213141516171819202122232425262728293031@Servicepublic class RedisServiceImpl implements RedisService { @Autowired private StringRedisTemplate stringRedisTemplate; @Override public void set(String key, String value) { stringRedisTemplate.opsForValue().set(key, value); } @Override public String get(String key) { return stringRedisTemplate.opsForValue().get(key); } @Override public boolean expire(String key, long expire) { return stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS); } @Override public void remove(String key) { stringRedisTemplate.delete(key); } @Override public Long increment(String key, long delta) { return stringRedisTemplate.opsForValue().increment(key,delta); }} Redis 应用 -&gt; 以 UmsMemberController （SSO 单点登录）为例 什么是单点登录（SSO） - 知乎 (zhihu.com) Controller 123456789101112131415161718192021@Controller@RequestMapping(&quot;/sso&quot;)@Api(tags = &quot;UmsMemberController&quot;, description = &quot;会员登录注册管理&quot;)public class UmsMemberController { @Autowired private UmsMemberService umsMemberService; @RequestMapping(value = &quot;/getAuthCode&quot;, method = RequestMethod.GET) @ResponseBody public ResultVO getAuthCode(@RequestParam String telephone) { return umsMemberService.generateAuthCode(telephone); } @RequestMapping(value = &quot;/verifyAuthCode&quot;, method = RequestMethod.POST) @ResponseBody public ResultVO updatePassword(@RequestParam String telephone, @RequestParam String authCode) { return umsMemberService.verifyAuthCode(telephone,authCode); }} Service 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class UmsMemberServiceImpl implements UmsMemberService { @Autowired RedisService redisService; @Value(&quot;${redis.key.prefix.authCode}&quot;) private String REDIS_KEY_PREFIX_AUTH_CODE; @Value(&quot;${redis.key.expire.authCode}&quot;) private Long AUTH_CODE_EXPIRE_SECONDS; @Override public ResultVO generateAuthCode(String telephone) { StringBuilder sb = new StringBuilder(); Random random = new Random(); for (int i = 0; i &lt; 6; i++) { sb.append(random.nextInt(10)); } //验证码绑定手机号并存储到redis redisService.set(REDIS_KEY_PREFIX_AUTH_CODE + telephone, sb.toString()); redisService.expire(REDIS_KEY_PREFIX_AUTH_CODE + telephone, AUTH_CODE_EXPIRE_SECONDS); return ResultVO.successWithData(sb.toString()); } @Override public ResultVO verifyAuthCode(String telephone, String authCode) { if (StrUtil.isEmpty(authCode)) { return ResultVO.failedWithMsg(&quot;请输入验证码&quot;); } String realAuthCode = redisService.get(REDIS_KEY_PREFIX_AUTH_CODE + telephone); boolean result = authCode.equals(realAuthCode); if (result) { return ResultVO.successWithMsg(&quot;验证码校验成功&quot;); } else { return ResultVO.failedWithMsg(&quot;验证码不正确&quot;); } }} SpringSecurity &amp; JWT引入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 引入常用的 JWT 工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@Componentpublic class JwtTokenUtil { private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class); private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;; private static final String CLAIM_KEY_CREATED = &quot;created&quot;; @Value(&quot;${jwt.secret}&quot;) private String secret; @Value(&quot;${jwt.expiration}&quot;) private Long expiration; /** * 根据负责生成JWT的token */ private String generateToken(Map&lt;String, Object&gt; claims) { return Jwts.builder() .setClaims(claims) .setExpiration(generateExpirationDate()) .signWith(SignatureAlgorithm.HS512, secret) .compact(); } /** * 从token中获取JWT中的负载 */ private Claims getClaimsFromToken(String token) { Claims claims = null; try { claims = Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); } catch (Exception e) { LOGGER.info(&quot;JWT格式验证失败:{}&quot;,token); } return claims; } /** * 生成token的过期时间 */ private Date generateExpirationDate() { return new Date(System.currentTimeMillis() + expiration * 1000); } /** * 从token中获取登录用户名 */ public String getUserNameFromToken(String token) { String username; try { Claims claims = getClaimsFromToken(token); username = claims.getSubject(); } catch (Exception e) { username = null; } return username; } /** * 验证token是否还有效 * * @param token 客户端传入的token * @param userDetails 从数据库中查询出来的用户信息 */ public boolean validateToken(String token, UserDetails userDetails) { String username = getUserNameFromToken(token); return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token); } /** * 判断token是否已经失效 */ private boolean isTokenExpired(String token) { Date expiredDate = getExpiredDateFromToken(token); return expiredDate.before(new Date()); } /** * 从token中获取过期时间 */ private Date getExpiredDateFromToken(String token) { Claims claims = getClaimsFromToken(token); return claims.getExpiration(); } /** * 根据用户信息生成token */ public String generateToken(UserDetails userDetails) { Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername()); claims.put(CLAIM_KEY_CREATED, new Date()); return generateToken(claims); } /** * 判断token是否可以被刷新 */ public boolean canRefresh(String token) { return !isTokenExpired(token); } /** * 刷新token */ public String refreshToken(String token) { Claims claims = getClaimsFromToken(token); claims.put(CLAIM_KEY_CREATED, new Date()); return generateToken(claims); }} Security 配置类 参考：(43条消息) Spring Security 常用配置详解_application.yml文件security_lukamao的博客-CSDN博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled=true)public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UmsAdminService adminService; @Autowired private RestfulAccessDeniedHandler restfulAccessDeniedHandler; @Autowired private RestAuthenticationEntryPoint restAuthenticationEntryPoint; @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity.csrf()// 由于使用的是JWT，我们这里不需要csrf .disable() .sessionManagement()// 基于token，所以不需要session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问 &quot;/&quot;, &quot;/*.html&quot;, &quot;/favicon.ico&quot;, &quot;/**/*.html&quot;, &quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/swagger-resources/**&quot;, &quot;/v2/api-docs/**&quot; ) .permitAll() .antMatchers(&quot;/admin/login&quot;, &quot;/admin/register&quot;)// 对登录注册要允许匿名访问 .permitAll() .antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求 .permitAll()// .antMatchers(&quot;/**&quot;)//测试时全部运行访问// .permitAll() .anyRequest()// 除上面外的所有请求全部需要鉴权认证 .authenticated(); // 禁用缓存 httpSecurity.headers().cacheControl(); // 添加JWT filter httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class); //添加自定义未授权和未登录结果返回 httpSecurity.exceptionHandling() .accessDeniedHandler(restfulAccessDeniedHandler) .authenticationEntryPoint(restAuthenticationEntryPoint); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService()) .passwordEncoder(passwordEncoder()); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public UserDetailsService userDetailsService() { //获取登录用户信息 return username -&gt; { UmsAdmin admin = adminService.getAdminByUsername(username); if (admin != null) { List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(admin.getId()); return new AdminUserDetails(admin,permissionList); } throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;); }; } @Bean public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter(){ return new JwtAuthenticationTokenFilter(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); }} UmsAdminController 实现了注册、登录、权限获取三个方法。 注册部分 Controller 12345678910@ApiOperation(value = &quot;用户注册&quot;) @RequestMapping(value = &quot;/register&quot;, method = RequestMethod.POST) @ResponseBody public Result&lt;UmsAdmin&gt; register(@RequestBody UmsAdminDto umsAdminDto, BindingResult result) { UmsAdmin umsAdmin = adminService.register(umsAdminDto); if (umsAdmin == null) { Result.failedWithMsg(&quot;用户名已存在&quot;); } return Result.successWithMsg(&quot;注册成功&quot;); } Service 12345678910111213141516171819@Override public UmsAdmin register(UmsAdminDto umsAdminDto) { UmsAdmin umsAdmin = new UmsAdmin(); BeanUtils.copyProperties(umsAdminDto, umsAdmin); umsAdmin.setCreateTime(new Date()); umsAdmin.setStatus(1); //查询是否有相同用户名的用户 UmsAdminExample example = new UmsAdminExample(); example.createCriteria().andUsernameEqualTo(umsAdmin.getUsername()); List&lt;UmsAdmin&gt; umsAdminList = umsAdminMapper.selectByExample(example); if (umsAdminList.size() &gt; 0) { return null; } //将密码进行加密操作 String encodePassword = passwordEncoder.encode(umsAdmin.getPassword()); umsAdmin.setPassword(encodePassword); umsAdminMapper.insert(umsAdmin); return umsAdmin; } 登录部分： 用户调用登录接口，登录成功后获取到JWT的token； 用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token； 后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。 Controller 注意这里用到了 BindingResult 返回信息校验 12345678910111213@ApiOperation(value = &quot;登录以后返回token&quot;) @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST) @ResponseBody public Result login(@RequestBody UmsAdminLoginDto umsAdminLoginDto, BindingResult result) { String token = adminService.login(umsAdminLoginDto.getUsername(), umsAdminLoginDto.getPassword()); if (token == null) { return Result.failedWithMsg(&quot;账户名或密码错误&quot;); } Map&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;(); tokenMap.put(&quot;token&quot;, token); tokenMap.put(&quot;tokenHead&quot;, tokenHead); return Result.successWithData(tokenMap); } Service 这里的 UserDetails 是 SpringSecurity 的对象 ，用于封装传入的 username 和 password。 (43条消息) SpringSecurity (2) UserDetailsService_caplike的博客-CSDN博客 12345678910111213141516@Override public String login(String username, String password) { String token = null; try { UserDetails userDetails = userDetailsService.loadUserByUsername(username); if (!passwordEncoder.matches(password, userDetails.getPassword())) { throw new BadCredentialsException(&quot;密码不正确&quot;); } UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authentication); token = jwtTokenUtil.generateToken(userDetails); } catch (AuthenticationException e) { LOGGER.warn(&quot;登录异常:{}&quot;, e.getMessage()); } return token; } 暂时跳过 Security 部分。 SpringTask 定时任务业务场景说明 用户对某商品进行下单操作； 系统需要根据用户购买的商品信息生成订单并锁定商品的库存； 系统设置了60分钟用户不付款就会取消订单； 开启一个定时任务，每隔10分钟检查下，如果有超时还未付款的订单，就取消订单并取消锁定的商品库存。 依赖与配置SpringTask 包含在 Spring 框架中，仅需添加一个 Config。 1234@Configuration@EnableSchedulingpublic class SpringTaskConfig {} 设置定时任务123456789101112131415@Componentpublic class OrderTimeOutCancelTask { private Logger LOGGER = LoggerFactory.getLogger(OrderTimeOutCancelTask.class); /** * cron表达式：Seconds Minutes Hours DayofMonth Month DayofWeek [Year] * 每10分钟扫描一次，扫描设定超时时间之前下的订单，如果没支付则取消该订单 */ @Scheduled(cron = &quot;0 0/10 * ? * ?&quot;) private void cancelTimeOutOrder() { // TODO: 2019/5/3 此处应调用取消订单的方法，具体查看mall项目源码 LOGGER.info(&quot;取消订单，并根据sku编号释放锁定库存&quot;); }} 搜索插件 Elasticsearch赋予项目以搜索、分析和探索数据的能力 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;artifactId&gt;&lt;/dependency&gt; 配置1234567spring: data: elasticsearch: repositories: enabled: true cluster-nodes: 127.0.0.1:9300 # es的连接地址及端口号 cluster-name: elasticsearch # es集群的名称 。。。 Debug执行代码生成时报错。 Cannot instantiate object of type com.moonlightqz.mymall.mbg.CommentGenerator 参考：MyBatis Generator报错：Cannot instantiate object of type_hanchao5272的博客-CSDN博客 解决：注释掉该代码。 1The specified target project directory \\src\\main\\java does not exist mybatis-generator生成报错The specified target project directory xxx does not exist及源码分析 - leoalasiga - 博客园 (cnblogs.com)","link":"/2023/05/10/deprecated/MyMall/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/05/05/deprecated/hello-world/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"Mall","slug":"Mall","link":"/tags/Mall/"}],"categories":[],"pages":[]}